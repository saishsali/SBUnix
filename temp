
./kernel:     file format elf64-x86-64


Disassembly of section .text:

ffffffff802000b0 <sys_read>:
}

int sys_read(int n)
{
    return 0;
}
ffffffff802000b0:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff802000b5:	c3                   	retq   

ffffffff802000b6 <sys_write>:

#define NUM_SYSCALLS 2

// These will get invoked in kernel mode. */
int sys_write(int n, uint64_t str, int len)
{
ffffffff802000b6:	48 83 ec 08          	sub    $0x8,%rsp
    // while(1) {
        kprintf("Value -  %s\n", str);
ffffffff802000ba:	48 8d 3d 33 1e 00 00 	lea    0x1e33(%rip),%rdi        # ffffffff80201ef4 <_x86_64_asm_ltr+0x5f>
ffffffff802000c1:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff802000c6:	e8 1a 05 00 00       	callq  ffffffff802005e5 <kprintf>
    // }
    
    return 100;
}
ffffffff802000cb:	b8 64 00 00 00       	mov    $0x64,%eax
ffffffff802000d0:	48 83 c4 08          	add    $0x8,%rsp
ffffffff802000d4:	c3                   	retq   

ffffffff802000d5 <syscall_handler>:
{
    
    void *func_ptr;
    uint64_t ret;

    if (syscall_no >= 0 && syscall_no < NUM_SYSCALLS) {
ffffffff802000d5:	48 83 ff 01          	cmp    $0x1,%rdi
ffffffff802000d9:	77 10                	ja     ffffffff802000eb <syscall_handler+0x16>
        
        func_ptr = syscall_tbl[syscall_no];
ffffffff802000db:	48 8d 05 be d4 08 00 	lea    0x8d4be(%rip),%rax        # ffffffff8028d5a0 <_binary_tarfs_end>
        __asm__ __volatile__(
ffffffff802000e2:	48 8b 04 f8          	mov    (%rax,%rdi,8),%rax
ffffffff802000e6:	ff d0                	callq  *%rax
ffffffff802000e8:	48 89 c0             	mov    %rax,%rax
ffffffff802000eb:	f3 c3                	repz retq 

ffffffff802000ed <page_to_physical_address>:
uint64_t holes[50] = {0};
uint64_t hole_index = 0;

uint64_t page_to_physical_address(Page *p) {
    /* Offset * 4096 */
    return (p - pages) << PAGE_SHIFT;
ffffffff802000ed:	48 8d 15 14 42 00 00 	lea    0x4214(%rip),%rdx        # ffffffff80204308 <pages>
ffffffff802000f4:	48 89 f8             	mov    %rdi,%rax
ffffffff802000f7:	48 2b 02             	sub    (%rdx),%rax
ffffffff802000fa:	48 c1 f8 04          	sar    $0x4,%rax
ffffffff802000fe:	48 c1 e0 0c          	shl    $0xc,%rax
}
ffffffff80200102:	c3                   	retq   

ffffffff80200103 <page_to_virtual_address>:

uint64_t page_to_virtual_address(Page *p) {
ffffffff80200103:	48 83 ec 08          	sub    $0x8,%rsp
    return KERNBASE + page_to_physical_address(p);
ffffffff80200107:	e8 e1 ff ff ff       	callq  ffffffff802000ed <page_to_physical_address>
ffffffff8020010c:	48 05 00 00 00 80    	add    $0xffffffff80000000,%rax
}
ffffffff80200112:	48 83 c4 08          	add    $0x8,%rsp
ffffffff80200116:	c3                   	retq   

ffffffff80200117 <page_init>:

void page_init(uint64_t start, uint64_t end, uint64_t physbase, uint64_t physfree) {
    static uint64_t index = 0;

    /* Start page descriptor array at KERBASE + physfree */
    pages = (Page *)(KERNBASE + physfree);
ffffffff80200117:	48 8d 91 00 00 00 80 	lea    -0x80000000(%rcx),%rdx
ffffffff8020011e:	48 8d 05 e3 41 00 00 	lea    0x41e3(%rip),%rax        # ffffffff80204308 <pages>
ffffffff80200125:	48 89 10             	mov    %rdx,(%rax)
    Page *prev = NULL;
    uint64_t i = 0;
    start = start / PAGE_SIZE;
ffffffff80200128:	48 c1 ef 0c          	shr    $0xc,%rdi
    end = end / PAGE_SIZE;
ffffffff8020012c:	48 c1 ee 0c          	shr    $0xc,%rsi

    /* Mark page index to start as in use so that it can never be allocated */
    for (i = index; i < start; i++) {
ffffffff80200130:	4c 8b 15 79 40 00 00 	mov    0x4079(%rip),%r10        # ffffffff802041b0 <index.1186>
ffffffff80200137:	4c 39 d7             	cmp    %r10,%rdi
ffffffff8020013a:	76 31                	jbe    ffffffff8020016d <page_init+0x56>
ffffffff8020013c:	4c 89 d2             	mov    %r10,%rdx
ffffffff8020013f:	48 c1 e2 04          	shl    $0x4,%rdx
ffffffff80200143:	4c 89 d0             	mov    %r10,%rax
        pages[i].reference_count = 1;
ffffffff80200146:	4c 8d 0d bb 41 00 00 	lea    0x41bb(%rip),%r9        # ffffffff80204308 <pages>
ffffffff8020014d:	49 89 d0             	mov    %rdx,%r8
ffffffff80200150:	4d 03 01             	add    (%r9),%r8
ffffffff80200153:	66 41 c7 40 08 01 00 	movw   $0x1,0x8(%r8)
        pages[i].next = NULL;
ffffffff8020015a:	49 c7 00 00 00 00 00 	movq   $0x0,(%r8)
    uint64_t i = 0;
    start = start / PAGE_SIZE;
    end = end / PAGE_SIZE;

    /* Mark page index to start as in use so that it can never be allocated */
    for (i = index; i < start; i++) {
ffffffff80200161:	48 ff c0             	inc    %rax
ffffffff80200164:	48 83 c2 10          	add    $0x10,%rdx
ffffffff80200168:	48 39 c7             	cmp    %rax,%rdi
ffffffff8020016b:	75 e0                	jne    ffffffff8020014d <page_init+0x36>
        pages[i].reference_count = 1;
        pages[i].next = NULL;
    }
    if(index > 0) {
ffffffff8020016d:	4d 85 d2             	test   %r10,%r10
ffffffff80200170:	74 3e                	je     ffffffff802001b0 <page_init+0x99>
        holes[hole_index++] = (uint64_t)&pages[index-1];
ffffffff80200172:	48 8d 15 87 3e 00 00 	lea    0x3e87(%rip),%rdx        # ffffffff80204000 <hole_index>
ffffffff80200179:	48 8b 02             	mov    (%rdx),%rax
ffffffff8020017c:	4c 8d 05 85 41 00 00 	lea    0x4185(%rip),%r8        # ffffffff80204308 <pages>
ffffffff80200183:	4d 8b 08             	mov    (%r8),%r9
ffffffff80200186:	4c 8d 05 93 3e 00 00 	lea    0x3e93(%rip),%r8        # ffffffff80204020 <holes>
ffffffff8020018d:	49 c1 e2 04          	shl    $0x4,%r10
ffffffff80200191:	4f 8d 54 11 f0       	lea    -0x10(%r9,%r10,1),%r10
ffffffff80200196:	4d 89 14 c0          	mov    %r10,(%r8,%rax,8)
        holes[hole_index++] = (uint64_t)&pages[start];
ffffffff8020019a:	4c 8d 50 02          	lea    0x2(%rax),%r10
ffffffff8020019e:	4c 89 12             	mov    %r10,(%rdx)
ffffffff802001a1:	48 89 fa             	mov    %rdi,%rdx
ffffffff802001a4:	48 c1 e2 04          	shl    $0x4,%rdx
ffffffff802001a8:	4c 01 ca             	add    %r9,%rdx
ffffffff802001ab:	49 89 54 c0 08       	mov    %rdx,0x8(%r8,%rax,8)
    }

    /* Mark page 0 as in use */
    if (start == 0) {
ffffffff802001b0:	48 85 ff             	test   %rdi,%rdi
ffffffff802001b3:	75 1c                	jne    ffffffff802001d1 <page_init+0xba>
        pages[0].reference_count = 1;
ffffffff802001b5:	48 8d 05 4c 41 00 00 	lea    0x414c(%rip),%rax        # ffffffff80204308 <pages>
ffffffff802001bc:	48 8b 00             	mov    (%rax),%rax
ffffffff802001bf:	66 c7 40 08 01 00    	movw   $0x1,0x8(%rax)
        pages[0].next = NULL;
ffffffff802001c5:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
        start++;
ffffffff802001cc:	bf 01 00 00 00       	mov    $0x1,%edi
    }

    for (i = start; i < end; i++) {
ffffffff802001d1:	48 39 f7             	cmp    %rsi,%rdi
ffffffff802001d4:	0f 83 06 01 00 00    	jae    ffffffff802002e0 <page_init+0x1c9>
        /* Mark memory until physfree as free but do not initialize page_free_list (Since bootloader page table exists in this region)*/
        if (i < (physfree / PAGE_SIZE)) {
ffffffff802001da:	49 89 c8             	mov    %rcx,%r8
ffffffff802001dd:	49 c1 e8 0c          	shr    $0xc,%r8
            pages[i].next = NULL;
            if (prev != NULL) {
                prev->next = &pages[i];
            }
            prev = &pages[i];
        } else if (i >= (physfree / PAGE_SIZE) && i < ROUND_UP((physfree + end * sizeof(Page)), PAGE_SIZE) / PAGE_SIZE) {
ffffffff802001e1:	48 89 f0             	mov    %rsi,%rax
ffffffff802001e4:	48 c1 e0 04          	shl    $0x4,%rax
ffffffff802001e8:	4c 8d 8c 01 ff 0f 00 	lea    0xfff(%rcx,%rax,1),%r9
ffffffff802001ef:	00 
ffffffff802001f0:	49 c1 e9 0c          	shr    $0xc,%r9
ffffffff802001f4:	48 89 f8             	mov    %rdi,%rax
ffffffff802001f7:	48 c1 e0 04          	shl    $0x4,%rax
ffffffff802001fb:	ba 00 00 00 00       	mov    $0x0,%edx
        start++;
    }

    for (i = start; i < end; i++) {
        /* Mark memory until physfree as free but do not initialize page_free_list (Since bootloader page table exists in this region)*/
        if (i < (physfree / PAGE_SIZE)) {
ffffffff80200200:	49 39 f8             	cmp    %rdi,%r8
ffffffff80200203:	76 45                	jbe    ffffffff8020024a <page_init+0x133>
            pages[i].reference_count = 0;
ffffffff80200205:	48 8d 0d fc 40 00 00 	lea    0x40fc(%rip),%rcx        # ffffffff80204308 <pages>
ffffffff8020020c:	49 89 c3             	mov    %rax,%r11
ffffffff8020020f:	4c 03 19             	add    (%rcx),%r11
ffffffff80200212:	66 41 c7 43 08 00 00 	movw   $0x0,0x8(%r11)
            pages[i].next = NULL;
ffffffff80200219:	49 c7 03 00 00 00 00 	movq   $0x0,(%r11)
            if (prev != NULL) {
ffffffff80200220:	48 85 d2             	test   %rdx,%rdx
ffffffff80200223:	74 10                	je     ffffffff80200235 <page_init+0x11e>
                prev->next = &pages[i];
ffffffff80200225:	48 8d 0d dc 40 00 00 	lea    0x40dc(%rip),%rcx        # ffffffff80204308 <pages>
ffffffff8020022c:	49 89 c2             	mov    %rax,%r10
ffffffff8020022f:	4c 03 11             	add    (%rcx),%r10
ffffffff80200232:	4c 89 12             	mov    %r10,(%rdx)
            }
            prev = &pages[i];
ffffffff80200235:	48 8d 15 cc 40 00 00 	lea    0x40cc(%rip),%rdx        # ffffffff80204308 <pages>
ffffffff8020023c:	48 89 c1             	mov    %rax,%rcx
ffffffff8020023f:	48 03 0a             	add    (%rdx),%rcx
ffffffff80200242:	48 89 ca             	mov    %rcx,%rdx
ffffffff80200245:	e9 86 00 00 00       	jmpq   ffffffff802002d0 <page_init+0x1b9>
        } else if (i >= (physfree / PAGE_SIZE) && i < ROUND_UP((physfree + end * sizeof(Page)), PAGE_SIZE) / PAGE_SIZE) {
ffffffff8020024a:	49 39 f9             	cmp    %rdi,%r9
ffffffff8020024d:	76 1d                	jbe    ffffffff8020026c <page_init+0x155>
            /* Mark memory used by page descriptor array as in use */
            pages[i].reference_count = 1;
ffffffff8020024f:	48 8d 0d b2 40 00 00 	lea    0x40b2(%rip),%rcx        # ffffffff80204308 <pages>
ffffffff80200256:	49 89 c3             	mov    %rax,%r11
ffffffff80200259:	4c 03 19             	add    (%rcx),%r11
ffffffff8020025c:	66 41 c7 43 08 01 00 	movw   $0x1,0x8(%r11)
            pages[i].next = NULL;
ffffffff80200263:	49 c7 03 00 00 00 00 	movq   $0x0,(%r11)
ffffffff8020026a:	eb 64                	jmp    ffffffff802002d0 <page_init+0x1b9>
        } else {
            /* Mark rest of the memory pages as free */
            pages[i].reference_count = 0;
ffffffff8020026c:	48 8d 0d 95 40 00 00 	lea    0x4095(%rip),%rcx        # ffffffff80204308 <pages>
ffffffff80200273:	49 89 c3             	mov    %rax,%r11
ffffffff80200276:	4c 03 19             	add    (%rcx),%r11
ffffffff80200279:	66 41 c7 43 08 00 00 	movw   $0x0,0x8(%r11)
            pages[i].next = NULL;
ffffffff80200280:	49 c7 03 00 00 00 00 	movq   $0x0,(%r11)
            if (prev != NULL) {
ffffffff80200287:	48 85 d2             	test   %rdx,%rdx
ffffffff8020028a:	74 10                	je     ffffffff8020029c <page_init+0x185>
                prev->next = &pages[i];
ffffffff8020028c:	48 8d 0d 75 40 00 00 	lea    0x4075(%rip),%rcx        # ffffffff80204308 <pages>
ffffffff80200293:	49 89 c2             	mov    %rax,%r10
ffffffff80200296:	4c 03 11             	add    (%rcx),%r10
ffffffff80200299:	4c 89 12             	mov    %r10,(%rdx)
            }
            if (page_free_list == NULL) {
ffffffff8020029c:	48 8d 15 5d 40 00 00 	lea    0x405d(%rip),%rdx        # ffffffff80204300 <page_free_list>
ffffffff802002a3:	48 83 3a 00          	cmpq   $0x0,(%rdx)
ffffffff802002a7:	75 17                	jne    ffffffff802002c0 <page_init+0x1a9>
                page_free_list = &pages[i];
ffffffff802002a9:	48 8d 15 58 40 00 00 	lea    0x4058(%rip),%rdx        # ffffffff80204308 <pages>
ffffffff802002b0:	48 89 c1             	mov    %rax,%rcx
ffffffff802002b3:	48 03 0a             	add    (%rdx),%rcx
ffffffff802002b6:	48 8d 15 43 40 00 00 	lea    0x4043(%rip),%rdx        # ffffffff80204300 <page_free_list>
ffffffff802002bd:	48 89 0a             	mov    %rcx,(%rdx)
            }
            prev = &pages[i];
ffffffff802002c0:	48 8d 15 41 40 00 00 	lea    0x4041(%rip),%rdx        # ffffffff80204308 <pages>
ffffffff802002c7:	48 89 c1             	mov    %rax,%rcx
ffffffff802002ca:	48 03 0a             	add    (%rdx),%rcx
ffffffff802002cd:	48 89 ca             	mov    %rcx,%rdx
        pages[0].reference_count = 1;
        pages[0].next = NULL;
        start++;
    }

    for (i = start; i < end; i++) {
ffffffff802002d0:	48 ff c7             	inc    %rdi
ffffffff802002d3:	48 83 c0 10          	add    $0x10,%rax
ffffffff802002d7:	48 39 fe             	cmp    %rdi,%rsi
ffffffff802002da:	0f 85 20 ff ff ff    	jne    ffffffff80200200 <page_init+0xe9>
            }
            prev = &pages[i];
        }
    }

    index = end;
ffffffff802002e0:	48 89 35 c9 3e 00 00 	mov    %rsi,0x3ec9(%rip)        # ffffffff802041b0 <index.1186>
ffffffff802002e7:	c3                   	retq   

ffffffff802002e8 <allocate_page>:
}

/* Allocate a page by returning first free page in the page free list */
Page *allocate_page() {
ffffffff802002e8:	53                   	push   %rbx
    if (page_free_list == NULL) {
ffffffff802002e9:	48 8d 05 10 40 00 00 	lea    0x4010(%rip),%rax        # ffffffff80204300 <page_free_list>
ffffffff802002f0:	48 8b 18             	mov    (%rax),%rbx
ffffffff802002f3:	48 85 db             	test   %rbx,%rbx
ffffffff802002f6:	75 13                	jne    ffffffff8020030b <allocate_page+0x23>
        kprintf("No free pages for allocation\n");
ffffffff802002f8:	48 8d 3d 02 1c 00 00 	lea    0x1c02(%rip),%rdi        # ffffffff80201f01 <_x86_64_asm_ltr+0x6c>
ffffffff802002ff:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80200304:	e8 dc 02 00 00       	callq  ffffffff802005e5 <kprintf>
        return NULL;
ffffffff80200309:	eb 13                	jmp    ffffffff8020031e <allocate_page+0x36>
    }
    Page *free_page = page_free_list;
    page_free_list = page_free_list->next;
ffffffff8020030b:	48 8b 13             	mov    (%rbx),%rdx
ffffffff8020030e:	48 8d 05 eb 3f 00 00 	lea    0x3feb(%rip),%rax        # ffffffff80204300 <page_free_list>
ffffffff80200315:	48 89 10             	mov    %rdx,(%rax)
    free_page->reference_count = 1;
ffffffff80200318:	66 c7 43 08 01 00    	movw   $0x1,0x8(%rbx)

    return free_page;
}
ffffffff8020031e:	48 89 d8             	mov    %rbx,%rax
ffffffff80200321:	5b                   	pop    %rbx
ffffffff80200322:	c3                   	retq   

ffffffff80200323 <allocate_pages>:

/* Allocate pages by returning first free page in free list and moving head pointer num_pages ahead */
Page *allocate_pages(int num_pages) {
ffffffff80200323:	53                   	push   %rbx
    if (page_free_list == NULL) {
ffffffff80200324:	48 8d 05 d5 3f 00 00 	lea    0x3fd5(%rip),%rax        # ffffffff80204300 <page_free_list>
ffffffff8020032b:	48 8b 18             	mov    (%rax),%rbx
ffffffff8020032e:	48 85 db             	test   %rbx,%rbx
ffffffff80200331:	74 09                	je     ffffffff8020033c <allocate_pages+0x19>
        kprintf("No free pages for allocation\n");
        return NULL;
    }
    Page *free_pages = page_free_list;
    while (num_pages-- > 0) {
ffffffff80200333:	8d 47 ff             	lea    -0x1(%rdi),%eax
ffffffff80200336:	85 ff                	test   %edi,%edi
ffffffff80200338:	7f 15                	jg     ffffffff8020034f <allocate_pages+0x2c>
ffffffff8020033a:	eb 30                	jmp    ffffffff8020036c <allocate_pages+0x49>
}

/* Allocate pages by returning first free page in free list and moving head pointer num_pages ahead */
Page *allocate_pages(int num_pages) {
    if (page_free_list == NULL) {
        kprintf("No free pages for allocation\n");
ffffffff8020033c:	48 8d 3d be 1b 00 00 	lea    0x1bbe(%rip),%rdi        # ffffffff80201f01 <_x86_64_asm_ltr+0x6c>
ffffffff80200343:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80200348:	e8 98 02 00 00       	callq  ffffffff802005e5 <kprintf>
        return NULL;
ffffffff8020034d:	eb 1d                	jmp    ffffffff8020036c <allocate_pages+0x49>
    }
    Page *free_pages = page_free_list;
    while (num_pages-- > 0) {
        page_free_list->reference_count = 1;
ffffffff8020034f:	48 8d 0d aa 3f 00 00 	lea    0x3faa(%rip),%rcx        # ffffffff80204300 <page_free_list>
ffffffff80200356:	48 8b 11             	mov    (%rcx),%rdx
ffffffff80200359:	66 c7 42 08 01 00    	movw   $0x1,0x8(%rdx)
        page_free_list = page_free_list->next;
ffffffff8020035f:	48 8b 12             	mov    (%rdx),%rdx
ffffffff80200362:	48 89 11             	mov    %rdx,(%rcx)
    if (page_free_list == NULL) {
        kprintf("No free pages for allocation\n");
        return NULL;
    }
    Page *free_pages = page_free_list;
    while (num_pages-- > 0) {
ffffffff80200365:	ff c8                	dec    %eax
ffffffff80200367:	83 f8 ff             	cmp    $0xffffffff,%eax
ffffffff8020036a:	75 ea                	jne    ffffffff80200356 <allocate_pages+0x33>
        page_free_list->reference_count = 1;
        page_free_list = page_free_list->next;
    }

    return free_pages;
}
ffffffff8020036c:	48 89 d8             	mov    %rbx,%rax
ffffffff8020036f:	5b                   	pop    %rbx
ffffffff80200370:	c3                   	retq   

ffffffff80200371 <deallocate_initial_pages>:

/* Since the memory below physbase can now (after paging) be used as free, point page_free list to the 1st page */
void deallocate_initial_pages(uint64_t physbase) {
ffffffff80200371:	48 83 ec 08          	sub    $0x8,%rsp
    pages[(physbase / PAGE_SIZE) - 1].next = page_free_list;
ffffffff80200375:	48 8d 15 84 3f 00 00 	lea    0x3f84(%rip),%rdx        # ffffffff80204300 <page_free_list>
ffffffff8020037c:	48 8b 32             	mov    (%rdx),%rsi
ffffffff8020037f:	48 c1 ef 0c          	shr    $0xc,%rdi
ffffffff80200383:	48 8d 0d 7e 3f 00 00 	lea    0x3f7e(%rip),%rcx        # ffffffff80204308 <pages>
ffffffff8020038a:	48 c1 e7 04          	shl    $0x4,%rdi
ffffffff8020038e:	48 89 f8             	mov    %rdi,%rax
ffffffff80200391:	48 03 01             	add    (%rcx),%rax
ffffffff80200394:	48 89 70 f0          	mov    %rsi,-0x10(%rax)
    page_free_list = &pages[1];
ffffffff80200398:	48 8b 39             	mov    (%rcx),%rdi
ffffffff8020039b:	48 83 c7 10          	add    $0x10,%rdi
ffffffff8020039f:	48 89 3a             	mov    %rdi,(%rdx)
    int count = 0;

    Page *last, *first;
    int i;
    // page before hole starts should point to page after hole ends
    for (i = 0; i < hole_index - 1; i = i + 2) {
ffffffff802003a2:	48 8d 05 57 3c 00 00 	lea    0x3c57(%rip),%rax        # ffffffff80204000 <hole_index>
ffffffff802003a9:	48 83 38 01          	cmpq   $0x1,(%rax)
ffffffff802003ad:	74 3c                	je     ffffffff802003eb <deallocate_initial_pages+0x7a>
ffffffff802003af:	b8 02 00 00 00       	mov    $0x2,%eax
        last = (Page *)(holes[i]);
ffffffff802003b4:	48 8d 0d 65 3c 00 00 	lea    0x3c65(%rip),%rcx        # ffffffff80204020 <holes>
    int count = 0;

    Page *last, *first;
    int i;
    // page before hole starts should point to page after hole ends
    for (i = 0; i < hole_index - 1; i = i + 2) {
ffffffff802003bb:	4c 8d 05 3e 3c 00 00 	lea    0x3c3e(%rip),%r8        # ffffffff80204000 <hole_index>
ffffffff802003c2:	eb 03                	jmp    ffffffff802003c7 <deallocate_initial_pages+0x56>
ffffffff802003c4:	48 89 f0             	mov    %rsi,%rax
ffffffff802003c7:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
ffffffff802003ce:	00 
        last = (Page *)(holes[i]);
        first = (Page *)(holes[i+1]);
        last->next = first;
ffffffff802003cf:	48 8b 74 0a f0       	mov    -0x10(%rdx,%rcx,1),%rsi
ffffffff802003d4:	48 8b 54 0a f8       	mov    -0x8(%rdx,%rcx,1),%rdx
ffffffff802003d9:	48 89 16             	mov    %rdx,(%rsi)
ffffffff802003dc:	48 8d 70 02          	lea    0x2(%rax),%rsi
    int count = 0;

    Page *last, *first;
    int i;
    // page before hole starts should point to page after hole ends
    for (i = 0; i < hole_index - 1; i = i + 2) {
ffffffff802003e0:	49 8b 10             	mov    (%r8),%rdx
ffffffff802003e3:	48 ff ca             	dec    %rdx
ffffffff802003e6:	48 39 c2             	cmp    %rax,%rdx
ffffffff802003e9:	77 d9                	ja     ffffffff802003c4 <deallocate_initial_pages+0x53>
        last = (Page *)(holes[i]);
        first = (Page *)(holes[i+1]);
        last->next = first;
    }

    while (p != NULL) {
ffffffff802003eb:	48 85 ff             	test   %rdi,%rdi
ffffffff802003ee:	74 11                	je     ffffffff80200401 <deallocate_initial_pages+0x90>
ffffffff802003f0:	be 00 00 00 00       	mov    $0x0,%esi
        count++;
ffffffff802003f5:	ff c6                	inc    %esi
        p = p->next;
ffffffff802003f7:	48 8b 3f             	mov    (%rdi),%rdi
        last = (Page *)(holes[i]);
        first = (Page *)(holes[i+1]);
        last->next = first;
    }

    while (p != NULL) {
ffffffff802003fa:	48 85 ff             	test   %rdi,%rdi
ffffffff802003fd:	75 f6                	jne    ffffffff802003f5 <deallocate_initial_pages+0x84>
ffffffff802003ff:	eb 05                	jmp    ffffffff80200406 <deallocate_initial_pages+0x95>
ffffffff80200401:	be 00 00 00 00       	mov    $0x0,%esi
        count++;
        p = p->next;
    }
    kprintf("\nNumber of pages: %d\n", count);
ffffffff80200406:	48 8d 3d 12 1b 00 00 	lea    0x1b12(%rip),%rdi        # ffffffff80201f1f <_x86_64_asm_ltr+0x8a>
ffffffff8020040d:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80200412:	e8 ce 01 00 00       	callq  ffffffff802005e5 <kprintf>
}
ffffffff80200417:	48 83 c4 08          	add    $0x8,%rsp
ffffffff8020041b:	c3                   	retq   

ffffffff8020041c <interrupt_handler0>:
#include <sys/keyboard.h>
#include <sys/syscall.h>
#include <sys/defs.h>

// Handler for first 32 interrupts (offset 0 - 31)
void interrupt_handler0() {}
ffffffff8020041c:	f3 c3                	repz retq 

ffffffff8020041e <interrupt_handler32>:

// Handler for timer interrupt (offset 32)
void interrupt_handler32() {
ffffffff8020041e:	f3 c3                	repz retq 

ffffffff80200420 <interrupt_handler33>:
    // timer_interrupt();
}

// Handler for keyboard interrupt (offset 33)
void interrupt_handler33() {
ffffffff80200420:	f3 c3                	repz retq 

ffffffff80200422 <interrupt_handler128>:
    // keyboard_interrupt();
}

// Handler for syscall
void interrupt_handler128() {
ffffffff80200422:	48 83 ec 08          	sub    $0x8,%rsp
	uint64_t syscall_no;
	__asm__ __volatile__("movq %%rax, %0;" : "=r"(syscall_no));
ffffffff80200426:	48 89 c7             	mov    %rax,%rdi
    syscall_handler(syscall_no);
ffffffff80200429:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff8020042e:	e8 a2 fc ff ff       	callq  ffffffff802000d5 <syscall_handler>
ffffffff80200433:	48 83 c4 08          	add    $0x8,%rsp
ffffffff80200437:	c3                   	retq   
ffffffff80200438:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff8020043f:	00 

ffffffff80200440 <scroll>:

void scroll() {
    char *vm;

    // If current address exceeds video memory last address
    if (video_memory >= (char *)VIDEO_MEM_END) {
ffffffff80200440:	48 8d 05 41 5f 00 00 	lea    0x5f41(%rip),%rax        # ffffffff80206388 <video_memory>
ffffffff80200447:	48 81 38 ff 8e 0b 80 	cmpq   $0xffffffff800b8eff,(%rax)
ffffffff8020044e:	76 53                	jbe    ffffffff802004a3 <scroll+0x63>
#define DEFAULT_COLOR 7

char *video_memory = (char *)VIDEO_MEM_START;
int scroll_flag = 1;

void scroll() {
ffffffff80200450:	53                   	push   %rbx
    char *vm;

    // If current address exceeds video memory last address
    if (video_memory >= (char *)VIDEO_MEM_END) {
        video_memory = memcpy((char*)VIDEO_MEM_START, (char*)(VIDEO_MEM_START + COLUMN_SIZE), (ROW_SIZE - 1) * COLUMN_SIZE);
ffffffff80200451:	ba 00 0f 00 00       	mov    $0xf00,%edx
ffffffff80200456:	48 c7 c6 a0 80 0b 80 	mov    $0xffffffff800b80a0,%rsi
ffffffff8020045d:	48 c7 c7 00 80 0b 80 	mov    $0xffffffff800b8000,%rdi
ffffffff80200464:	e8 62 04 00 00       	callq  ffffffff802008cb <memcpy>
ffffffff80200469:	48 8d 1d 18 5f 00 00 	lea    0x5f18(%rip),%rbx        # ffffffff80206388 <video_memory>
ffffffff80200470:	48 89 03             	mov    %rax,(%rbx)
        video_memory = memset((char*)(VIDEO_MEM_END - COLUMN_SIZE), 0, COLUMN_SIZE);
ffffffff80200473:	ba a0 00 00 00       	mov    $0xa0,%edx
ffffffff80200478:	be 00 00 00 00       	mov    $0x0,%esi
ffffffff8020047d:	48 c7 c7 60 8e 0b 80 	mov    $0xffffffff800b8e60,%rdi
ffffffff80200484:	e8 cd 17 00 00       	callq  ffffffff80201c56 <memset>
ffffffff80200489:	48 89 03             	mov    %rax,(%rbx)

        // Set Default color to white
        for (vm = (char*)(VIDEO_MEM_END - COLUMN_SIZE + 1); vm < (char*)(VIDEO_MEM_END); vm += 2)
ffffffff8020048c:	48 c7 c0 61 8e 0b 80 	mov    $0xffffffff800b8e61,%rax
            *vm = DEFAULT_COLOR;
ffffffff80200493:	c6 00 07             	movb   $0x7,(%rax)
    if (video_memory >= (char *)VIDEO_MEM_END) {
        video_memory = memcpy((char*)VIDEO_MEM_START, (char*)(VIDEO_MEM_START + COLUMN_SIZE), (ROW_SIZE - 1) * COLUMN_SIZE);
        video_memory = memset((char*)(VIDEO_MEM_END - COLUMN_SIZE), 0, COLUMN_SIZE);

        // Set Default color to white
        for (vm = (char*)(VIDEO_MEM_END - COLUMN_SIZE + 1); vm < (char*)(VIDEO_MEM_END); vm += 2)
ffffffff80200496:	48 83 c0 02          	add    $0x2,%rax
ffffffff8020049a:	48 3d 01 8f 0b 80    	cmp    $0xffffffff800b8f01,%rax
ffffffff802004a0:	75 f1                	jne    ffffffff80200493 <scroll+0x53>
            *vm = DEFAULT_COLOR;
        }
}
ffffffff802004a2:	5b                   	pop    %rbx
ffffffff802004a3:	f3 c3                	repz retq 

ffffffff802004a5 <control_character>:

int control_character(char c) {
    switch (c) {
ffffffff802004a5:	40 80 ff 0a          	cmp    $0xa,%dil
ffffffff802004a9:	74 12                	je     ffffffff802004bd <control_character+0x18>
ffffffff802004ab:	40 80 ff 0d          	cmp    $0xd,%dil
ffffffff802004af:	74 47                	je     ffffffff802004f8 <control_character+0x53>
ffffffff802004b1:	40 80 ff 09          	cmp    $0x9,%dil
ffffffff802004b5:	0f 85 88 00 00 00    	jne    ffffffff80200543 <control_character+0x9e>
ffffffff802004bb:	eb 75                	jmp    ffffffff80200532 <control_character+0x8d>
        case '\n': // Move to the start of the next line
            video_memory += ((int)((char*)VIDEO_MEM_END - video_memory) % COLUMN_SIZE);
ffffffff802004bd:	48 8d 35 c4 5e 00 00 	lea    0x5ec4(%rip),%rsi        # ffffffff80206388 <video_memory>
ffffffff802004c4:	48 8b 3e             	mov    (%rsi),%rdi
ffffffff802004c7:	b9 00 8f 0b 80       	mov    $0x800b8f00,%ecx
ffffffff802004cc:	29 f9                	sub    %edi,%ecx
ffffffff802004ce:	ba 67 66 66 66       	mov    $0x66666667,%edx
ffffffff802004d3:	89 c8                	mov    %ecx,%eax
ffffffff802004d5:	f7 ea                	imul   %edx
ffffffff802004d7:	c1 fa 06             	sar    $0x6,%edx
ffffffff802004da:	89 c8                	mov    %ecx,%eax
ffffffff802004dc:	c1 f8 1f             	sar    $0x1f,%eax
ffffffff802004df:	29 c2                	sub    %eax,%edx
ffffffff802004e1:	69 d2 a0 00 00 00    	imul   $0xa0,%edx,%edx
ffffffff802004e7:	29 d1                	sub    %edx,%ecx
ffffffff802004e9:	48 63 c9             	movslq %ecx,%rcx
ffffffff802004ec:	48 01 f9             	add    %rdi,%rcx
ffffffff802004ef:	48 89 0e             	mov    %rcx,(%rsi)
            return 1;
ffffffff802004f2:	b8 01 00 00 00       	mov    $0x1,%eax
ffffffff802004f7:	c3                   	retq   

        case '\r': // Move to the start of the current line
            video_memory -= ((int)(video_memory - (char*)VIDEO_MEM_START) % COLUMN_SIZE);
ffffffff802004f8:	48 8d 3d 89 5e 00 00 	lea    0x5e89(%rip),%rdi        # ffffffff80206388 <video_memory>
ffffffff802004ff:	48 8b 37             	mov    (%rdi),%rsi
ffffffff80200502:	8d 8e 00 80 f4 7f    	lea    0x7ff48000(%rsi),%ecx
ffffffff80200508:	ba 67 66 66 66       	mov    $0x66666667,%edx
ffffffff8020050d:	89 c8                	mov    %ecx,%eax
ffffffff8020050f:	f7 ea                	imul   %edx
ffffffff80200511:	c1 fa 06             	sar    $0x6,%edx
ffffffff80200514:	89 c8                	mov    %ecx,%eax
ffffffff80200516:	c1 f8 1f             	sar    $0x1f,%eax
ffffffff80200519:	29 c2                	sub    %eax,%edx
ffffffff8020051b:	69 d2 a0 00 00 00    	imul   $0xa0,%edx,%edx
ffffffff80200521:	29 d1                	sub    %edx,%ecx
ffffffff80200523:	48 63 c9             	movslq %ecx,%rcx
ffffffff80200526:	48 29 ce             	sub    %rcx,%rsi
ffffffff80200529:	48 89 37             	mov    %rsi,(%rdi)
            return 1;
ffffffff8020052c:	b8 01 00 00 00       	mov    $0x1,%eax
ffffffff80200531:	c3                   	retq   

        case '\t': // Move one tab horizontal space
            video_memory += 8;
ffffffff80200532:	48 8d 05 4f 5e 00 00 	lea    0x5e4f(%rip),%rax        # ffffffff80206388 <video_memory>
ffffffff80200539:	48 83 00 08          	addq   $0x8,(%rax)
            return 1;
ffffffff8020053d:	b8 01 00 00 00       	mov    $0x1,%eax
ffffffff80200542:	c3                   	retq   

        default:
            return 0;
ffffffff80200543:	b8 00 00 00 00       	mov    $0x0,%eax
    }
}
ffffffff80200548:	c3                   	retq   

ffffffff80200549 <print_character>:

void print_character(char c) {
ffffffff80200549:	53                   	push   %rbx
ffffffff8020054a:	89 fb                	mov    %edi,%ebx
    if (scroll_flag == 1)
ffffffff8020054c:	48 8d 05 2d 5e 00 00 	lea    0x5e2d(%rip),%rax        # ffffffff80206380 <scroll_flag>
ffffffff80200553:	83 38 01             	cmpl   $0x1,(%rax)
ffffffff80200556:	75 0a                	jne    ffffffff80200562 <print_character+0x19>
        scroll();
ffffffff80200558:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff8020055d:	e8 de fe ff ff       	callq  ffffffff80200440 <scroll>
    if (!control_character(c)) {
ffffffff80200562:	0f be fb             	movsbl %bl,%edi
ffffffff80200565:	e8 3b ff ff ff       	callq  ffffffff802004a5 <control_character>
ffffffff8020056a:	85 c0                	test   %eax,%eax
ffffffff8020056c:	75 10                	jne    ffffffff8020057e <print_character+0x35>
        *video_memory = c;
ffffffff8020056e:	48 8d 05 13 5e 00 00 	lea    0x5e13(%rip),%rax        # ffffffff80206388 <video_memory>
ffffffff80200575:	48 8b 10             	mov    (%rax),%rdx
ffffffff80200578:	88 1a                	mov    %bl,(%rdx)
        video_memory += 2;
ffffffff8020057a:	48 83 00 02          	addq   $0x2,(%rax)
    }
}
ffffffff8020057e:	5b                   	pop    %rbx
ffffffff8020057f:	c3                   	retq   

ffffffff80200580 <decimal_conversion>:

char *decimal_conversion(unsigned long long decimal, int base) {
ffffffff80200580:	48 83 ec 20          	sub    $0x20,%rsp
    static char buf[SIZE];
    char *result = &buf[SIZE - 1], representation[] = "0123456789ABCDEF";
ffffffff80200584:	48 b8 30 31 32 33 34 	movabs $0x3736353433323130,%rax
ffffffff8020058b:	35 36 37 
ffffffff8020058e:	48 89 44 24 0f       	mov    %rax,0xf(%rsp)
ffffffff80200593:	48 b8 38 39 41 42 43 	movabs $0x4645444342413938,%rax
ffffffff8020059a:	44 45 46 
ffffffff8020059d:	48 89 44 24 17       	mov    %rax,0x17(%rsp)
ffffffff802005a2:	c6 44 24 1f 00       	movb   $0x0,0x1f(%rsp)
    int remainder;

    if (decimal == 0) {
        return "0";
ffffffff802005a7:	48 8d 05 87 19 00 00 	lea    0x1987(%rip),%rax        # ffffffff80201f35 <_x86_64_asm_ltr+0xa0>
char *decimal_conversion(unsigned long long decimal, int base) {
    static char buf[SIZE];
    char *result = &buf[SIZE - 1], representation[] = "0123456789ABCDEF";
    int remainder;

    if (decimal == 0) {
ffffffff802005ae:	48 85 ff             	test   %rdi,%rdi
ffffffff802005b1:	74 2d                	je     ffffffff802005e0 <decimal_conversion+0x60>
ffffffff802005b3:	48 8d 0d 69 3c 00 00 	lea    0x3c69(%rip),%rcx        # ffffffff80204223 <buf.1175+0x63>
        return "0";
    }

    while (decimal > 0) {
        remainder = decimal % base;
ffffffff802005ba:	48 63 f6             	movslq %esi,%rsi
ffffffff802005bd:	48 89 f8             	mov    %rdi,%rax
ffffffff802005c0:	ba 00 00 00 00       	mov    $0x0,%edx
ffffffff802005c5:	48 f7 f6             	div    %rsi
        decimal /= base;
ffffffff802005c8:	48 89 c7             	mov    %rax,%rdi
        result--;
ffffffff802005cb:	48 ff c9             	dec    %rcx
        *result = representation[remainder];
ffffffff802005ce:	48 63 d2             	movslq %edx,%rdx
ffffffff802005d1:	0f b6 54 14 0f       	movzbl 0xf(%rsp,%rdx,1),%edx
ffffffff802005d6:	88 11                	mov    %dl,(%rcx)

    if (decimal == 0) {
        return "0";
    }

    while (decimal > 0) {
ffffffff802005d8:	48 85 c0             	test   %rax,%rax
ffffffff802005db:	75 e0                	jne    ffffffff802005bd <decimal_conversion+0x3d>
        remainder = decimal % base;
        decimal /= base;
        result--;
ffffffff802005dd:	48 89 c8             	mov    %rcx,%rax
        *result = representation[remainder];
    }

    return result;
}
ffffffff802005e0:	48 83 c4 20          	add    $0x20,%rsp
ffffffff802005e4:	c3                   	retq   

ffffffff802005e5 <kprintf>:
    }
}

// Write string pointer by fmt to standard output
void kprintf(const char *fmt, ...)
{
ffffffff802005e5:	48 83 ec 58          	sub    $0x58,%rsp
ffffffff802005e9:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
ffffffff802005ee:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
ffffffff802005f3:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
ffffffff802005f8:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
ffffffff802005fd:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
    va_list arguments;
    va_start(arguments, fmt);
ffffffff80200602:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%rsp)
ffffffff80200609:	00 
ffffffff8020060a:	48 8d 44 24 60       	lea    0x60(%rsp),%rax
ffffffff8020060f:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
ffffffff80200614:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
ffffffff80200619:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    output(fmt, arguments);
ffffffff8020061e:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
ffffffff80200623:	e8 05 00 00 00       	callq  ffffffff8020062d <output>
    va_end(arguments);
}
ffffffff80200628:	48 83 c4 58          	add    $0x58,%rsp
ffffffff8020062c:	c3                   	retq   

ffffffff8020062d <output>:

    return result;
}

// Handle format specifiers and write to console
void output(const char *fmt, va_list arguments) {
ffffffff8020062d:	41 55                	push   %r13
ffffffff8020062f:	41 54                	push   %r12
ffffffff80200631:	55                   	push   %rbp
ffffffff80200632:	53                   	push   %rbx
ffffffff80200633:	48 83 ec 08          	sub    $0x8,%rsp
ffffffff80200637:	48 89 fb             	mov    %rdi,%rbx
    int num;
    const char *c;

    while (*fmt) {
ffffffff8020063a:	0f b6 3f             	movzbl (%rdi),%edi
ffffffff8020063d:	40 84 ff             	test   %dil,%dil
ffffffff80200640:	0f 84 a7 01 00 00    	je     ffffffff802007ed <output+0x1c0>
ffffffff80200646:	48 89 f5             	mov    %rsi,%rbp
        if (*fmt == '%') {
            c = fmt;
            fmt++;

            switch(*fmt) {
ffffffff80200649:	4c 8d 25 4c 18 00 00 	lea    0x184c(%rip),%r12        # ffffffff80201e9c <_x86_64_asm_ltr+0x7>
void output(const char *fmt, va_list arguments) {
    int num;
    const char *c;

    while (*fmt) {
        if (*fmt == '%') {
ffffffff80200650:	40 80 ff 25          	cmp    $0x25,%dil
ffffffff80200654:	0f 85 75 01 00 00    	jne    ffffffff802007cf <output+0x1a2>
            c = fmt;
            fmt++;
ffffffff8020065a:	4c 8d 6b 01          	lea    0x1(%rbx),%r13

            switch(*fmt) {
ffffffff8020065e:	0f b6 43 01          	movzbl 0x1(%rbx),%eax
ffffffff80200662:	83 e8 63             	sub    $0x63,%eax
ffffffff80200665:	3c 15                	cmp    $0x15,%al
ffffffff80200667:	0f 87 4d 01 00 00    	ja     ffffffff802007ba <output+0x18d>
ffffffff8020066d:	0f b6 c0             	movzbl %al,%eax
ffffffff80200670:	49 63 04 84          	movslq (%r12,%rax,4),%rax
ffffffff80200674:	4c 01 e0             	add    %r12,%rax
ffffffff80200677:	ff e0                	jmpq   *%rax
                case 'c':
                    print_character(va_arg(arguments, int));
ffffffff80200679:	8b 45 00             	mov    0x0(%rbp),%eax
ffffffff8020067c:	83 f8 2f             	cmp    $0x2f,%eax
ffffffff8020067f:	77 0e                	ja     ffffffff8020068f <output+0x62>
ffffffff80200681:	89 c2                	mov    %eax,%edx
ffffffff80200683:	48 03 55 10          	add    0x10(%rbp),%rdx
ffffffff80200687:	83 c0 08             	add    $0x8,%eax
ffffffff8020068a:	89 45 00             	mov    %eax,0x0(%rbp)
ffffffff8020068d:	eb 0c                	jmp    ffffffff8020069b <output+0x6e>
ffffffff8020068f:	48 8b 55 08          	mov    0x8(%rbp),%rdx
ffffffff80200693:	48 8d 42 08          	lea    0x8(%rdx),%rax
ffffffff80200697:	48 89 45 08          	mov    %rax,0x8(%rbp)
ffffffff8020069b:	0f be 3a             	movsbl (%rdx),%edi
ffffffff8020069e:	e8 a6 fe ff ff       	callq  ffffffff80200549 <print_character>
                    break;
ffffffff802006a3:	e9 33 01 00 00       	jmpq   ffffffff802007db <output+0x1ae>

                case 'd':
                    num = va_arg(arguments, int);
ffffffff802006a8:	8b 45 00             	mov    0x0(%rbp),%eax
ffffffff802006ab:	83 f8 2f             	cmp    $0x2f,%eax
ffffffff802006ae:	77 0e                	ja     ffffffff802006be <output+0x91>
ffffffff802006b0:	89 c2                	mov    %eax,%edx
ffffffff802006b2:	48 03 55 10          	add    0x10(%rbp),%rdx
ffffffff802006b6:	83 c0 08             	add    $0x8,%eax
ffffffff802006b9:	89 45 00             	mov    %eax,0x0(%rbp)
ffffffff802006bc:	eb 0c                	jmp    ffffffff802006ca <output+0x9d>
ffffffff802006be:	48 8b 55 08          	mov    0x8(%rbp),%rdx
ffffffff802006c2:	48 8d 42 08          	lea    0x8(%rdx),%rax
ffffffff802006c6:	48 89 45 08          	mov    %rax,0x8(%rbp)
ffffffff802006ca:	8b 1a                	mov    (%rdx),%ebx
                    if (num < 0)
ffffffff802006cc:	85 db                	test   %ebx,%ebx
ffffffff802006ce:	79 0a                	jns    ffffffff802006da <output+0xad>
                        print_character('-');
ffffffff802006d0:	bf 2d 00 00 00       	mov    $0x2d,%edi
ffffffff802006d5:	e8 6f fe ff ff       	callq  ffffffff80200549 <print_character>
                    kprintf(decimal_conversion(num, 10));
ffffffff802006da:	48 63 fb             	movslq %ebx,%rdi
ffffffff802006dd:	be 0a 00 00 00       	mov    $0xa,%esi
ffffffff802006e2:	e8 99 fe ff ff       	callq  ffffffff80200580 <decimal_conversion>
ffffffff802006e7:	48 89 c7             	mov    %rax,%rdi
ffffffff802006ea:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff802006ef:	e8 f1 fe ff ff       	callq  ffffffff802005e5 <kprintf>
                    break;
ffffffff802006f4:	e9 e2 00 00 00       	jmpq   ffffffff802007db <output+0x1ae>

                case 'x':
                    kprintf(decimal_conversion(va_arg(arguments, unsigned long long), 16));
ffffffff802006f9:	8b 45 00             	mov    0x0(%rbp),%eax
ffffffff802006fc:	83 f8 2f             	cmp    $0x2f,%eax
ffffffff802006ff:	77 0e                	ja     ffffffff8020070f <output+0xe2>
ffffffff80200701:	89 c2                	mov    %eax,%edx
ffffffff80200703:	48 03 55 10          	add    0x10(%rbp),%rdx
ffffffff80200707:	83 c0 08             	add    $0x8,%eax
ffffffff8020070a:	89 45 00             	mov    %eax,0x0(%rbp)
ffffffff8020070d:	eb 0c                	jmp    ffffffff8020071b <output+0xee>
ffffffff8020070f:	48 8b 55 08          	mov    0x8(%rbp),%rdx
ffffffff80200713:	48 8d 42 08          	lea    0x8(%rdx),%rax
ffffffff80200717:	48 89 45 08          	mov    %rax,0x8(%rbp)
ffffffff8020071b:	be 10 00 00 00       	mov    $0x10,%esi
ffffffff80200720:	48 8b 3a             	mov    (%rdx),%rdi
ffffffff80200723:	e8 58 fe ff ff       	callq  ffffffff80200580 <decimal_conversion>
ffffffff80200728:	48 89 c7             	mov    %rax,%rdi
ffffffff8020072b:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80200730:	e8 b0 fe ff ff       	callq  ffffffff802005e5 <kprintf>
                    break;
ffffffff80200735:	e9 a1 00 00 00       	jmpq   ffffffff802007db <output+0x1ae>

                case 's':
                    kprintf(va_arg(arguments, char*));
ffffffff8020073a:	8b 45 00             	mov    0x0(%rbp),%eax
ffffffff8020073d:	83 f8 2f             	cmp    $0x2f,%eax
ffffffff80200740:	77 0e                	ja     ffffffff80200750 <output+0x123>
ffffffff80200742:	89 c2                	mov    %eax,%edx
ffffffff80200744:	48 03 55 10          	add    0x10(%rbp),%rdx
ffffffff80200748:	83 c0 08             	add    $0x8,%eax
ffffffff8020074b:	89 45 00             	mov    %eax,0x0(%rbp)
ffffffff8020074e:	eb 0c                	jmp    ffffffff8020075c <output+0x12f>
ffffffff80200750:	48 8b 55 08          	mov    0x8(%rbp),%rdx
ffffffff80200754:	48 8d 42 08          	lea    0x8(%rdx),%rax
ffffffff80200758:	48 89 45 08          	mov    %rax,0x8(%rbp)
ffffffff8020075c:	48 8b 3a             	mov    (%rdx),%rdi
ffffffff8020075f:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80200764:	e8 7c fe ff ff       	callq  ffffffff802005e5 <kprintf>
                    break;
ffffffff80200769:	eb 70                	jmp    ffffffff802007db <output+0x1ae>

                case 'p':
                    kprintf("0x");
ffffffff8020076b:	48 8d 3d c5 17 00 00 	lea    0x17c5(%rip),%rdi        # ffffffff80201f37 <_x86_64_asm_ltr+0xa2>
ffffffff80200772:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80200777:	e8 69 fe ff ff       	callq  ffffffff802005e5 <kprintf>
                    kprintf(decimal_conversion(va_arg(arguments, unsigned long long), 16));
ffffffff8020077c:	8b 45 00             	mov    0x0(%rbp),%eax
ffffffff8020077f:	83 f8 2f             	cmp    $0x2f,%eax
ffffffff80200782:	77 0e                	ja     ffffffff80200792 <output+0x165>
ffffffff80200784:	89 c2                	mov    %eax,%edx
ffffffff80200786:	48 03 55 10          	add    0x10(%rbp),%rdx
ffffffff8020078a:	83 c0 08             	add    $0x8,%eax
ffffffff8020078d:	89 45 00             	mov    %eax,0x0(%rbp)
ffffffff80200790:	eb 0c                	jmp    ffffffff8020079e <output+0x171>
ffffffff80200792:	48 8b 55 08          	mov    0x8(%rbp),%rdx
ffffffff80200796:	48 8d 42 08          	lea    0x8(%rdx),%rax
ffffffff8020079a:	48 89 45 08          	mov    %rax,0x8(%rbp)
ffffffff8020079e:	be 10 00 00 00       	mov    $0x10,%esi
ffffffff802007a3:	48 8b 3a             	mov    (%rdx),%rdi
ffffffff802007a6:	e8 d5 fd ff ff       	callq  ffffffff80200580 <decimal_conversion>
ffffffff802007ab:	48 89 c7             	mov    %rax,%rdi
ffffffff802007ae:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff802007b3:	e8 2d fe ff ff       	callq  ffffffff802005e5 <kprintf>
                    break;
ffffffff802007b8:	eb 21                	jmp    ffffffff802007db <output+0x1ae>

                default:
                    // If no format specifier is matched, write as it is
                    print_character(*c);
ffffffff802007ba:	bf 25 00 00 00       	mov    $0x25,%edi
ffffffff802007bf:	e8 85 fd ff ff       	callq  ffffffff80200549 <print_character>
                    print_character(*fmt);
ffffffff802007c4:	0f be 7b 01          	movsbl 0x1(%rbx),%edi
ffffffff802007c8:	e8 7c fd ff ff       	callq  ffffffff80200549 <print_character>
ffffffff802007cd:	eb 0c                	jmp    ffffffff802007db <output+0x1ae>
            }
        } else {
            print_character(*fmt);
ffffffff802007cf:	40 0f be ff          	movsbl %dil,%edi
ffffffff802007d3:	e8 71 fd ff ff       	callq  ffffffff80200549 <print_character>
ffffffff802007d8:	49 89 dd             	mov    %rbx,%r13
        }
        fmt++;
ffffffff802007db:	49 8d 5d 01          	lea    0x1(%r13),%rbx
// Handle format specifiers and write to console
void output(const char *fmt, va_list arguments) {
    int num;
    const char *c;

    while (*fmt) {
ffffffff802007df:	41 0f b6 7d 01       	movzbl 0x1(%r13),%edi
ffffffff802007e4:	40 84 ff             	test   %dil,%dil
ffffffff802007e7:	0f 85 63 fe ff ff    	jne    ffffffff80200650 <output+0x23>
        } else {
            print_character(*fmt);
        }
        fmt++;
    }
}
ffffffff802007ed:	48 83 c4 08          	add    $0x8,%rsp
ffffffff802007f1:	5b                   	pop    %rbx
ffffffff802007f2:	5d                   	pop    %rbp
ffffffff802007f3:	41 5c                	pop    %r12
ffffffff802007f5:	41 5d                	pop    %r13
ffffffff802007f7:	c3                   	retq   

ffffffff802007f8 <kprintf_pos>:
    output(fmt, arguments);
    va_end(arguments);
}

// Write at a specific position to standard output
void kprintf_pos(int row, int column, const char *fmt, ...) {
ffffffff802007f8:	41 54                	push   %r12
ffffffff802007fa:	55                   	push   %rbp
ffffffff802007fb:	53                   	push   %rbx
ffffffff802007fc:	48 83 ec 50          	sub    $0x50,%rsp
ffffffff80200800:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
ffffffff80200805:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
ffffffff8020080a:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
    char *vm = video_memory;
ffffffff8020080f:	48 8d 1d 72 5b 00 00 	lea    0x5b72(%rip),%rbx        # ffffffff80206388 <video_memory>
ffffffff80200816:	4c 8b 23             	mov    (%rbx),%r12
    va_list arguments;
    scroll_flag = 0;
ffffffff80200819:	48 8d 2d 60 5b 00 00 	lea    0x5b60(%rip),%rbp        # ffffffff80206380 <scroll_flag>
ffffffff80200820:	c7 45 00 00 00 00 00 	movl   $0x0,0x0(%rbp)
    va_start(arguments, fmt);
ffffffff80200827:	c7 44 24 08 18 00 00 	movl   $0x18,0x8(%rsp)
ffffffff8020082e:	00 
ffffffff8020082f:	48 8d 44 24 70       	lea    0x70(%rsp),%rax
ffffffff80200834:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
ffffffff80200839:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
ffffffff8020083e:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    video_memory = (char *)VIDEO_MEM_START + row * COLUMN_SIZE + column * 2;
ffffffff80200843:	69 c7 a0 00 00 00    	imul   $0xa0,%edi,%eax
ffffffff80200849:	48 98                	cltq   
ffffffff8020084b:	01 f6                	add    %esi,%esi
ffffffff8020084d:	48 63 f6             	movslq %esi,%rsi
ffffffff80200850:	48 8d 84 30 00 80 0b 	lea    -0x7ff48000(%rax,%rsi,1),%rax
ffffffff80200857:	80 
ffffffff80200858:	48 89 03             	mov    %rax,(%rbx)
    output(fmt, arguments);
ffffffff8020085b:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
ffffffff80200860:	48 89 d7             	mov    %rdx,%rdi
ffffffff80200863:	e8 c5 fd ff ff       	callq  ffffffff8020062d <output>
    va_end(arguments);
    video_memory = vm;
ffffffff80200868:	4c 89 23             	mov    %r12,(%rbx)
    scroll_flag = 1;
ffffffff8020086b:	c7 45 00 01 00 00 00 	movl   $0x1,0x0(%rbp)
}
ffffffff80200872:	48 83 c4 50          	add    $0x50,%rsp
ffffffff80200876:	5b                   	pop    %rbx
ffffffff80200877:	5d                   	pop    %rbp
ffffffff80200878:	41 5c                	pop    %r12
ffffffff8020087a:	c3                   	retq   

ffffffff8020087b <clear_screen>:

// Clear entire screen and set default color to white
void clear_screen() {
ffffffff8020087b:	48 83 ec 08          	sub    $0x8,%rsp
    char *vm = (char *)VIDEO_MEM_START;
    memset(vm, 0, ROW_SIZE * COLUMN_SIZE);
ffffffff8020087f:	ba a0 0f 00 00       	mov    $0xfa0,%edx
ffffffff80200884:	be 00 00 00 00       	mov    $0x0,%esi
ffffffff80200889:	48 c7 c7 00 80 0b 80 	mov    $0xffffffff800b8000,%rdi
ffffffff80200890:	e8 c1 13 00 00       	callq  ffffffff80201c56 <memset>

    // Set Default color to white
    for (vm = (char*)(VIDEO_MEM_START + 1); vm < (char*)(VIDEO_MEM_START + ROW_SIZE * COLUMN_SIZE); vm += 2)
ffffffff80200895:	48 c7 c0 01 80 0b 80 	mov    $0xffffffff800b8001,%rax
        *vm = DEFAULT_COLOR;
ffffffff8020089c:	c6 00 07             	movb   $0x7,(%rax)
void clear_screen() {
    char *vm = (char *)VIDEO_MEM_START;
    memset(vm, 0, ROW_SIZE * COLUMN_SIZE);

    // Set Default color to white
    for (vm = (char*)(VIDEO_MEM_START + 1); vm < (char*)(VIDEO_MEM_START + ROW_SIZE * COLUMN_SIZE); vm += 2)
ffffffff8020089f:	48 83 c0 02          	add    $0x2,%rax
ffffffff802008a3:	48 3d a1 8f 0b 80    	cmp    $0xffffffff800b8fa1,%rax
ffffffff802008a9:	75 f1                	jne    ffffffff8020089c <clear_screen+0x21>
        *vm = DEFAULT_COLOR;
}
ffffffff802008ab:	48 83 c4 08          	add    $0x8,%rsp
ffffffff802008af:	c3                   	retq   

ffffffff802008b0 <inb>:
#include <sys/defs.h>

unsigned char _x86_64_inb(unsigned short int port);

unsigned char inb (unsigned short int port) {
ffffffff802008b0:	48 83 ec 08          	sub    $0x8,%rsp
    unsigned char ch = _x86_64_inb(port);
ffffffff802008b4:	0f b7 ff             	movzwl %di,%edi
ffffffff802008b7:	e8 ae 15 00 00       	callq  ffffffff80201e6a <_x86_64_inb>
    return ch;
}
ffffffff802008bc:	48 83 c4 08          	add    $0x8,%rsp
ffffffff802008c0:	c3                   	retq   

ffffffff802008c1 <inl>:

uint32_t inl(uint16_t port) {
    uint32_t ret;
    __asm__ volatile(
ffffffff802008c1:	89 fa                	mov    %edi,%edx
ffffffff802008c3:	ed                   	in     (%dx),%eax
        : "=a" (ret)
        : "Nd" (port)
    );

    return ret;
}
ffffffff802008c4:	c3                   	retq   

ffffffff802008c5 <outl>:

void outl (uint16_t port, uint32_t data) {
    __asm__ volatile(
ffffffff802008c5:	89 f0                	mov    %esi,%eax
ffffffff802008c7:	89 fa                	mov    %edi,%edx
ffffffff802008c9:	ef                   	out    %eax,(%dx)
ffffffff802008ca:	c3                   	retq   

ffffffff802008cb <memcpy>:
#include <sys/defs.h>

// Copy string from destination to source
void *memcpy(void *dest, void *src, size_t n) {
ffffffff802008cb:	48 89 f8             	mov    %rdi,%rax
    char *source = (char *)src, *destination = (char *)dest;
   	int i;

    for (i = 0; i < n; i++)
ffffffff802008ce:	48 85 d2             	test   %rdx,%rdx
ffffffff802008d1:	74 1f                	je     ffffffff802008f2 <memcpy+0x27>
ffffffff802008d3:	b9 00 00 00 00       	mov    $0x0,%ecx
ffffffff802008d8:	41 b8 00 00 00 00    	mov    $0x0,%r8d
        destination[i] = source[i];
ffffffff802008de:	44 0f b6 0c 0e       	movzbl (%rsi,%rcx,1),%r9d
ffffffff802008e3:	44 88 0c 08          	mov    %r9b,(%rax,%rcx,1)
// Copy string from destination to source
void *memcpy(void *dest, void *src, size_t n) {
    char *source = (char *)src, *destination = (char *)dest;
   	int i;

    for (i = 0; i < n; i++)
ffffffff802008e7:	41 ff c0             	inc    %r8d
ffffffff802008ea:	49 63 c8             	movslq %r8d,%rcx
ffffffff802008ed:	48 39 d1             	cmp    %rdx,%rcx
ffffffff802008f0:	72 ec                	jb     ffffffff802008de <memcpy+0x13>
        destination[i] = source[i];

    return destination;
}
ffffffff802008f2:	f3 c3                	repz retq 

ffffffff802008f4 <virtual_to_physical_address>:

/* Page map level 4 */
PML4 *pml4;

uint64_t virtual_to_physical_address(void *virtual_address) {
    return (uint64_t)virtual_address - KERNBASE;
ffffffff802008f4:	b8 00 00 00 80       	mov    $0x80000000,%eax
ffffffff802008f9:	48 01 f8             	add    %rdi,%rax
}
ffffffff802008fc:	c3                   	retq   

ffffffff802008fd <physical_to_virtual_address>:

uint64_t physical_to_virtual_address(void *physical_address) {
    return (uint64_t)physical_address + KERNBASE;
ffffffff802008fd:	48 8d 87 00 00 00 80 	lea    -0x80000000(%rdi),%rax
}
ffffffff80200904:	c3                   	retq   

ffffffff80200905 <load_cr3>:

/* Load page table base address in CR3 register */
void load_cr3() {
ffffffff80200905:	53                   	push   %rbx
    uint64_t cr3 = virtual_to_physical_address(pml4);
ffffffff80200906:	48 8d 05 03 3a 00 00 	lea    0x3a03(%rip),%rax        # ffffffff80204310 <pml4>
ffffffff8020090d:	48 8b 38             	mov    (%rax),%rdi
ffffffff80200910:	e8 df ff ff ff       	callq  ffffffff802008f4 <virtual_to_physical_address>
    __asm__ volatile(
ffffffff80200915:	48 89 c3             	mov    %rax,%rbx
ffffffff80200918:	0f 22 db             	mov    %rbx,%cr3
        "movq %0, %%cr3;"
        :
        : "b" (cr3)
    );
}
ffffffff8020091b:	5b                   	pop    %rbx
ffffffff8020091c:	c3                   	retq   

ffffffff8020091d <allocate_pdpt>:

/* Allocate Page Directory Pointer Table */
PDPT *allocate_pdpt(PML4 *pml4, uint64_t pml4_index) {
ffffffff8020091d:	55                   	push   %rbp
ffffffff8020091e:	53                   	push   %rbx
ffffffff8020091f:	48 83 ec 08          	sub    $0x8,%rsp
ffffffff80200923:	48 89 fb             	mov    %rdi,%rbx
ffffffff80200926:	48 89 f5             	mov    %rsi,%rbp
    Page *p = allocate_page();
ffffffff80200929:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff8020092e:	e8 b5 f9 ff ff       	callq  ffffffff802002e8 <allocate_page>
    PDPT *pdpt = (PDPT *)page_to_physical_address(p);
ffffffff80200933:	48 89 c7             	mov    %rax,%rdi
ffffffff80200936:	e8 b2 f7 ff ff       	callq  ffffffff802000ed <page_to_physical_address>
    uint64_t pdpt_entry = (uint64_t)pdpt;
    pdpt_entry |= (PTE_P | PTE_W | PTE_U);
    pml4->entries[pml4_index] = pdpt_entry;
ffffffff8020093b:	48 89 c2             	mov    %rax,%rdx
ffffffff8020093e:	48 83 ca 07          	or     $0x7,%rdx
ffffffff80200942:	48 89 14 eb          	mov    %rdx,(%rbx,%rbp,8)

    return (PDPT *)(physical_to_virtual_address(pdpt));
ffffffff80200946:	48 89 c7             	mov    %rax,%rdi
ffffffff80200949:	e8 af ff ff ff       	callq  ffffffff802008fd <physical_to_virtual_address>
}
ffffffff8020094e:	48 83 c4 08          	add    $0x8,%rsp
ffffffff80200952:	5b                   	pop    %rbx
ffffffff80200953:	5d                   	pop    %rbp
ffffffff80200954:	c3                   	retq   

ffffffff80200955 <allocate_pdt>:

/* Allocate Page Directory Table */
PDT *allocate_pdt(PDPT *pdpt, uint64_t pdpt_index) {
ffffffff80200955:	55                   	push   %rbp
ffffffff80200956:	53                   	push   %rbx
ffffffff80200957:	48 83 ec 08          	sub    $0x8,%rsp
ffffffff8020095b:	48 89 fb             	mov    %rdi,%rbx
ffffffff8020095e:	48 89 f5             	mov    %rsi,%rbp
    Page *p = allocate_page();
ffffffff80200961:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80200966:	e8 7d f9 ff ff       	callq  ffffffff802002e8 <allocate_page>
    PDT *pdt = (PDT *)page_to_physical_address(p);
ffffffff8020096b:	48 89 c7             	mov    %rax,%rdi
ffffffff8020096e:	e8 7a f7 ff ff       	callq  ffffffff802000ed <page_to_physical_address>
    uint64_t pdt_entry = (uint64_t)pdt;
    pdt_entry |= (PTE_P | PTE_W | PTE_U);
    pdpt->entries[pdpt_index] = pdt_entry;
ffffffff80200973:	48 89 c2             	mov    %rax,%rdx
ffffffff80200976:	48 83 ca 07          	or     $0x7,%rdx
ffffffff8020097a:	48 89 14 eb          	mov    %rdx,(%rbx,%rbp,8)

    return (PDT *)(physical_to_virtual_address(pdt));
ffffffff8020097e:	48 89 c7             	mov    %rax,%rdi
ffffffff80200981:	e8 77 ff ff ff       	callq  ffffffff802008fd <physical_to_virtual_address>
}
ffffffff80200986:	48 83 c4 08          	add    $0x8,%rsp
ffffffff8020098a:	5b                   	pop    %rbx
ffffffff8020098b:	5d                   	pop    %rbp
ffffffff8020098c:	c3                   	retq   

ffffffff8020098d <allocate_pt>:

/* Allocate Page Table */
PT *allocate_pt(PDT *pdt, uint64_t pdt_index) {
ffffffff8020098d:	55                   	push   %rbp
ffffffff8020098e:	53                   	push   %rbx
ffffffff8020098f:	48 83 ec 08          	sub    $0x8,%rsp
ffffffff80200993:	48 89 fb             	mov    %rdi,%rbx
ffffffff80200996:	48 89 f5             	mov    %rsi,%rbp
    Page *p = allocate_page();
ffffffff80200999:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff8020099e:	e8 45 f9 ff ff       	callq  ffffffff802002e8 <allocate_page>
    PT *pt = (PT *)page_to_physical_address(p);
ffffffff802009a3:	48 89 c7             	mov    %rax,%rdi
ffffffff802009a6:	e8 42 f7 ff ff       	callq  ffffffff802000ed <page_to_physical_address>
    uint64_t pt_entry = (uint64_t)pt;
    pt_entry |= (PTE_P | PTE_W | PTE_U);
    pdt->entries[pdt_index] = pt_entry;
ffffffff802009ab:	48 89 c2             	mov    %rax,%rdx
ffffffff802009ae:	48 83 ca 07          	or     $0x7,%rdx
ffffffff802009b2:	48 89 14 eb          	mov    %rdx,(%rbx,%rbp,8)

    return (PT *)(physical_to_virtual_address(pt));
ffffffff802009b6:	48 89 c7             	mov    %rax,%rdi
ffffffff802009b9:	e8 3f ff ff ff       	callq  ffffffff802008fd <physical_to_virtual_address>
}
ffffffff802009be:	48 83 c4 08          	add    $0x8,%rsp
ffffffff802009c2:	5b                   	pop    %rbx
ffffffff802009c3:	5d                   	pop    %rbp
ffffffff802009c4:	c3                   	retq   

ffffffff802009c5 <map_page>:

/* Map a Virtual address to a physical address */
void map_page(uint64_t virtual_address, uint64_t physical_address) {
ffffffff802009c5:	41 55                	push   %r13
ffffffff802009c7:	41 54                	push   %r12
ffffffff802009c9:	55                   	push   %rbp
ffffffff802009ca:	53                   	push   %rbx
ffffffff802009cb:	48 83 ec 08          	sub    $0x8,%rsp
ffffffff802009cf:	49 89 f5             	mov    %rsi,%r13
    PDPT *pdpt;
    PDT *pdt;
    PT *pt;
    uint64_t pml4_index = PML4_INDEX(virtual_address);
ffffffff802009d2:	48 89 fe             	mov    %rdi,%rsi
ffffffff802009d5:	48 c1 ee 27          	shr    $0x27,%rsi
ffffffff802009d9:	81 e6 ff 01 00 00    	and    $0x1ff,%esi
    uint64_t pdpt_index = PDPT_INDEX(virtual_address);
ffffffff802009df:	49 89 fc             	mov    %rdi,%r12
ffffffff802009e2:	49 c1 ec 1e          	shr    $0x1e,%r12
ffffffff802009e6:	41 81 e4 ff 01 00 00 	and    $0x1ff,%r12d
    uint64_t pdt_index = PDT_INDEX(virtual_address);
ffffffff802009ed:	48 89 fd             	mov    %rdi,%rbp
ffffffff802009f0:	48 c1 ed 15          	shr    $0x15,%rbp
ffffffff802009f4:	81 e5 ff 01 00 00    	and    $0x1ff,%ebp
    uint64_t pt_index = PT_INDEX(virtual_address);
ffffffff802009fa:	48 c1 ef 0c          	shr    $0xc,%rdi
ffffffff802009fe:	48 89 fb             	mov    %rdi,%rbx
ffffffff80200a01:	81 e3 ff 01 00 00    	and    $0x1ff,%ebx

    uint64_t pml4_entry = pml4->entries[pml4_index];
ffffffff80200a07:	48 8d 05 02 39 00 00 	lea    0x3902(%rip),%rax        # ffffffff80204310 <pml4>
ffffffff80200a0e:	48 8b 38             	mov    (%rax),%rdi
ffffffff80200a11:	48 8b 04 f7          	mov    (%rdi,%rsi,8),%rax
    if (pml4_entry & PTE_P) {
ffffffff80200a15:	a8 01                	test   $0x1,%al
ffffffff80200a17:	74 10                	je     ffffffff80200a29 <map_page+0x64>
        pdpt = (PDPT *)GET_ADDRESS(pml4_entry);
        pdpt = (PDPT *)physical_to_virtual_address(pdpt);
ffffffff80200a19:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff80200a1f:	48 89 c7             	mov    %rax,%rdi
ffffffff80200a22:	e8 d6 fe ff ff       	callq  ffffffff802008fd <physical_to_virtual_address>
ffffffff80200a27:	eb 05                	jmp    ffffffff80200a2e <map_page+0x69>
    } else {
        pdpt = allocate_pdpt(pml4, pml4_index);
ffffffff80200a29:	e8 ef fe ff ff       	callq  ffffffff8020091d <allocate_pdpt>
    }

    uint64_t pdpt_entry = pdpt->entries[pdpt_index];
ffffffff80200a2e:	4a 8b 14 e0          	mov    (%rax,%r12,8),%rdx
    if (pdpt_entry & PTE_P) {
ffffffff80200a32:	f6 c2 01             	test   $0x1,%dl
ffffffff80200a35:	74 11                	je     ffffffff80200a48 <map_page+0x83>
        pdt = (PDT *)GET_ADDRESS(pdpt_entry);
        pdt = (PDT *)physical_to_virtual_address(pdt);
ffffffff80200a37:	48 81 e2 00 f0 ff ff 	and    $0xfffffffffffff000,%rdx
ffffffff80200a3e:	48 89 d7             	mov    %rdx,%rdi
ffffffff80200a41:	e8 b7 fe ff ff       	callq  ffffffff802008fd <physical_to_virtual_address>
ffffffff80200a46:	eb 0b                	jmp    ffffffff80200a53 <map_page+0x8e>
    } else {
        pdt = allocate_pdt(pdpt, pdpt_index);
ffffffff80200a48:	4c 89 e6             	mov    %r12,%rsi
ffffffff80200a4b:	48 89 c7             	mov    %rax,%rdi
ffffffff80200a4e:	e8 02 ff ff ff       	callq  ffffffff80200955 <allocate_pdt>
    }

    uint64_t pdt_entry = pdt->entries[pdt_index];
ffffffff80200a53:	48 8b 14 e8          	mov    (%rax,%rbp,8),%rdx
    if (pdt_entry & PTE_P) {
ffffffff80200a57:	f6 c2 01             	test   $0x1,%dl
ffffffff80200a5a:	74 11                	je     ffffffff80200a6d <map_page+0xa8>
        pt = (PT *)GET_ADDRESS(pdt_entry);
        pt = (PT *)physical_to_virtual_address(pt);
ffffffff80200a5c:	48 81 e2 00 f0 ff ff 	and    $0xfffffffffffff000,%rdx
ffffffff80200a63:	48 89 d7             	mov    %rdx,%rdi
ffffffff80200a66:	e8 92 fe ff ff       	callq  ffffffff802008fd <physical_to_virtual_address>
ffffffff80200a6b:	eb 0b                	jmp    ffffffff80200a78 <map_page+0xb3>
    } else {
        pt = allocate_pt(pdt, pdt_index);
ffffffff80200a6d:	48 89 ee             	mov    %rbp,%rsi
ffffffff80200a70:	48 89 c7             	mov    %rax,%rdi
ffffffff80200a73:	e8 15 ff ff ff       	callq  ffffffff8020098d <allocate_pt>
    }

    pt->entries[pt_index] = physical_address | (PTE_P | PTE_W | PTE_U);
ffffffff80200a78:	49 83 cd 07          	or     $0x7,%r13
ffffffff80200a7c:	4c 89 2c d8          	mov    %r13,(%rax,%rbx,8)
}
ffffffff80200a80:	48 83 c4 08          	add    $0x8,%rsp
ffffffff80200a84:	5b                   	pop    %rbx
ffffffff80200a85:	5d                   	pop    %rbp
ffffffff80200a86:	41 5c                	pop    %r12
ffffffff80200a88:	41 5d                	pop    %r13
ffffffff80200a8a:	c3                   	retq   

ffffffff80200a8b <map_kernel_memory>:

/*
    Map kernel memory from virtual address KERNBASE + physbase => physical address physbase to
    Virtual address KERNBASE + physfree => physical address physfree
*/
void map_kernel_memory(uint64_t physbase, uint64_t physfree) {
ffffffff80200a8b:	41 54                	push   %r12
ffffffff80200a8d:	55                   	push   %rbp
ffffffff80200a8e:	53                   	push   %rbx
ffffffff80200a8f:	48 89 fb             	mov    %rdi,%rbx
ffffffff80200a92:	48 89 f5             	mov    %rsi,%rbp
    uint64_t kernel_virtual_address = (uint64_t)(KERNBASE + physbase);
ffffffff80200a95:	4c 8d a7 00 00 00 80 	lea    -0x80000000(%rdi),%r12
    uint64_t pml4_index = PML4_INDEX(kernel_virtual_address);
    uint64_t pdpt_index = PDPT_INDEX(kernel_virtual_address);
    uint64_t pdt_index = PDT_INDEX(kernel_virtual_address);

    Page *p = allocate_page();
ffffffff80200a9c:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80200aa1:	e8 42 f8 ff ff       	callq  ffffffff802002e8 <allocate_page>
    pml4 = (PML4 *)page_to_virtual_address(p);
ffffffff80200aa6:	48 89 c7             	mov    %rax,%rdi
ffffffff80200aa9:	e8 55 f6 ff ff       	callq  ffffffff80200103 <page_to_virtual_address>
ffffffff80200aae:	48 8d 15 5b 38 00 00 	lea    0x385b(%rip),%rdx        # ffffffff80204310 <pml4>
ffffffff80200ab5:	48 89 02             	mov    %rax,(%rdx)
    PDPT *pdpt = allocate_pdpt(pml4, pml4_index);
ffffffff80200ab8:	4c 89 e6             	mov    %r12,%rsi
ffffffff80200abb:	48 c1 ee 27          	shr    $0x27,%rsi
ffffffff80200abf:	81 e6 ff 01 00 00    	and    $0x1ff,%esi
ffffffff80200ac5:	48 89 c7             	mov    %rax,%rdi
ffffffff80200ac8:	e8 50 fe ff ff       	callq  ffffffff8020091d <allocate_pdpt>
    PDT *pdt = allocate_pdt(pdpt, pdpt_index);
ffffffff80200acd:	4c 89 e6             	mov    %r12,%rsi
ffffffff80200ad0:	48 c1 ee 1e          	shr    $0x1e,%rsi
ffffffff80200ad4:	81 e6 ff 01 00 00    	and    $0x1ff,%esi
ffffffff80200ada:	48 89 c7             	mov    %rax,%rdi
ffffffff80200add:	e8 73 fe ff ff       	callq  ffffffff80200955 <allocate_pdt>
    PT *pt = allocate_pt(pdt, pdt_index);
ffffffff80200ae2:	4c 89 e6             	mov    %r12,%rsi
ffffffff80200ae5:	48 c1 ee 15          	shr    $0x15,%rsi
ffffffff80200ae9:	81 e6 ff 01 00 00    	and    $0x1ff,%esi
ffffffff80200aef:	48 89 c7             	mov    %rax,%rdi
ffffffff80200af2:	e8 96 fe ff ff       	callq  ffffffff8020098d <allocate_pt>

    uint64_t physical_address = physbase;
    uint64_t virtual_address  = kernel_virtual_address;

    while (physical_address < physfree) {
ffffffff80200af7:	48 39 eb             	cmp    %rbp,%rbx
ffffffff80200afa:	73 22                	jae    ffffffff80200b1e <map_kernel_memory+0x93>
        uint64_t pt_index = PT_INDEX(virtual_address);
        pt->entries[pt_index] = physical_address | (PTE_P | PTE_W | PTE_U);
ffffffff80200afc:	48 89 da             	mov    %rbx,%rdx
ffffffff80200aff:	48 c1 e2 2b          	shl    $0x2b,%rdx
ffffffff80200b03:	48 c1 ea 37          	shr    $0x37,%rdx
ffffffff80200b07:	48 89 d9             	mov    %rbx,%rcx
ffffffff80200b0a:	48 83 c9 07          	or     $0x7,%rcx
ffffffff80200b0e:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)
        physical_address += PAGE_SIZE;
ffffffff80200b12:	48 81 c3 00 10 00 00 	add    $0x1000,%rbx
    PT *pt = allocate_pt(pdt, pdt_index);

    uint64_t physical_address = physbase;
    uint64_t virtual_address  = kernel_virtual_address;

    while (physical_address < physfree) {
ffffffff80200b19:	48 39 dd             	cmp    %rbx,%rbp
ffffffff80200b1c:	77 de                	ja     ffffffff80200afc <map_kernel_memory+0x71>
        uint64_t pt_index = PT_INDEX(virtual_address);
        pt->entries[pt_index] = physical_address | (PTE_P | PTE_W | PTE_U);
        physical_address += PAGE_SIZE;
        virtual_address += PAGE_SIZE;
    }
}
ffffffff80200b1e:	5b                   	pop    %rbx
ffffffff80200b1f:	5d                   	pop    %rbp
ffffffff80200b20:	41 5c                	pop    %r12
ffffffff80200b22:	c3                   	retq   

ffffffff80200b23 <map_available_memory>:

/* Map the entire available memory starting from 0x0 to last physical address */
void map_available_memory(uint64_t last_physical_address) {
ffffffff80200b23:	55                   	push   %rbp
ffffffff80200b24:	53                   	push   %rbx
ffffffff80200b25:	48 83 ec 08          	sub    $0x8,%rsp
    uint64_t physical_address = 0x0UL;
    uint64_t virtual_address = KERNBASE;

    while (physical_address < last_physical_address) {
ffffffff80200b29:	48 85 ff             	test   %rdi,%rdi
ffffffff80200b2c:	74 23                	je     ffffffff80200b51 <map_available_memory+0x2e>
ffffffff80200b2e:	48 89 fd             	mov    %rdi,%rbp
ffffffff80200b31:	bb 00 00 00 00       	mov    $0x0,%ebx
        map_page(virtual_address, physical_address);
ffffffff80200b36:	48 8d bb 00 00 00 80 	lea    -0x80000000(%rbx),%rdi
ffffffff80200b3d:	48 89 de             	mov    %rbx,%rsi
ffffffff80200b40:	e8 80 fe ff ff       	callq  ffffffff802009c5 <map_page>
        virtual_address += PAGE_SIZE;
        physical_address += PAGE_SIZE;
ffffffff80200b45:	48 81 c3 00 10 00 00 	add    $0x1000,%rbx
/* Map the entire available memory starting from 0x0 to last physical address */
void map_available_memory(uint64_t last_physical_address) {
    uint64_t physical_address = 0x0UL;
    uint64_t virtual_address = KERNBASE;

    while (physical_address < last_physical_address) {
ffffffff80200b4c:	48 39 dd             	cmp    %rbx,%rbp
ffffffff80200b4f:	77 e5                	ja     ffffffff80200b36 <map_available_memory+0x13>
        map_page(virtual_address, physical_address);
        virtual_address += PAGE_SIZE;
        physical_address += PAGE_SIZE;
    }
    /* map the video memory physical address to the virtual address */
    map_page((uint64_t)(KERNBASE + VIDEO_MEMORY), VIDEO_MEMORY);
ffffffff80200b51:	be 00 80 0b 00       	mov    $0xb8000,%esi
ffffffff80200b56:	48 c7 c7 00 80 0b 80 	mov    $0xffffffff800b8000,%rdi
ffffffff80200b5d:	e8 63 fe ff ff       	callq  ffffffff802009c5 <map_page>
}
ffffffff80200b62:	48 83 c4 08          	add    $0x8,%rsp
ffffffff80200b66:	5b                   	pop    %rbx
ffffffff80200b67:	5d                   	pop    %rbp
ffffffff80200b68:	c3                   	retq   

ffffffff80200b69 <setup_page_tables>:

/* Setup page tables */
void setup_page_tables(uint64_t physbase, uint64_t physfree, uint64_t last_physical_address) {
ffffffff80200b69:	53                   	push   %rbx
ffffffff80200b6a:	48 89 d3             	mov    %rdx,%rbx
    map_kernel_memory(physbase, physfree);
ffffffff80200b6d:	e8 19 ff ff ff       	callq  ffffffff80200a8b <map_kernel_memory>
    map_available_memory(last_physical_address);
ffffffff80200b72:	48 89 df             	mov    %rbx,%rdi
ffffffff80200b75:	e8 a9 ff ff ff       	callq  ffffffff80200b23 <map_available_memory>
}
ffffffff80200b7a:	5b                   	pop    %rbx
ffffffff80200b7b:	c3                   	retq   

ffffffff80200b7c <kmalloc>:
#include <sys/defs.h>
#include <sys/page_descriptor.h>
#include <sys/paging.h>
#include <sys/string.h>

void *kmalloc(size_t size) {
ffffffff80200b7c:	41 54                	push   %r12
ffffffff80200b7e:	55                   	push   %rbp
ffffffff80200b7f:	53                   	push   %rbx
    uint64_t start_address, virtual_address, num_pages;
	Page *p = NULL;

    num_pages = (ROUND_UP(size, PAGE_SIZE)) / PAGE_SIZE;
ffffffff80200b80:	48 8d 9f ff 0f 00 00 	lea    0xfff(%rdi),%rbx
ffffffff80200b87:	48 c1 eb 0c          	shr    $0xc,%rbx
	p = allocate_pages(num_pages);
ffffffff80200b8b:	89 df                	mov    %ebx,%edi
ffffffff80200b8d:	e8 91 f7 ff ff       	callq  ffffffff80200323 <allocate_pages>
ffffffff80200b92:	48 89 c5             	mov    %rax,%rbp
    start_address = page_to_virtual_address(p);
ffffffff80200b95:	48 89 c7             	mov    %rax,%rdi
ffffffff80200b98:	e8 66 f5 ff ff       	callq  ffffffff80200103 <page_to_virtual_address>
ffffffff80200b9d:	49 89 c4             	mov    %rax,%r12
    virtual_address = start_address;

    while (num_pages--) {
ffffffff80200ba0:	48 85 db             	test   %rbx,%rbx
ffffffff80200ba3:	74 23                	je     ffffffff80200bc8 <kmalloc+0x4c>
        // Not required to map pages as of now
        // map_page(virtual_address, page_to_physical_address(p));
        memset((void *)virtual_address, 0, PAGE_SIZE);
ffffffff80200ba5:	ba 00 10 00 00       	mov    $0x1000,%edx
ffffffff80200baa:	be 00 00 00 00       	mov    $0x0,%esi
ffffffff80200baf:	48 89 c7             	mov    %rax,%rdi
ffffffff80200bb2:	e8 9f 10 00 00       	callq  ffffffff80201c56 <memset>
        p = p->next;
ffffffff80200bb7:	48 8b 6d 00          	mov    0x0(%rbp),%rbp
        virtual_address = page_to_virtual_address(p);
ffffffff80200bbb:	48 89 ef             	mov    %rbp,%rdi
ffffffff80200bbe:	e8 40 f5 ff ff       	callq  ffffffff80200103 <page_to_virtual_address>
    num_pages = (ROUND_UP(size, PAGE_SIZE)) / PAGE_SIZE;
	p = allocate_pages(num_pages);
    start_address = page_to_virtual_address(p);
    virtual_address = start_address;

    while (num_pages--) {
ffffffff80200bc3:	48 ff cb             	dec    %rbx
ffffffff80200bc6:	75 dd                	jne    ffffffff80200ba5 <kmalloc+0x29>
        p = p->next;
        virtual_address = page_to_virtual_address(p);
    }

	return (void*) start_address;
}
ffffffff80200bc8:	4c 89 e0             	mov    %r12,%rax
ffffffff80200bcb:	5b                   	pop    %rbx
ffffffff80200bcc:	5d                   	pop    %rbp
ffffffff80200bcd:	41 5c                	pop    %r12
ffffffff80200bcf:	c3                   	retq   

ffffffff80200bd0 <start>:
#define INITIAL_STACK_SIZE 4096
uint8_t initial_stack[INITIAL_STACK_SIZE]__attribute__((aligned(16)));
uint32_t* loader_stack;
extern char kernmem, physbase;

void start(uint32_t *modulep, void *physbase, void *physfree) {
ffffffff80200bd0:	41 57                	push   %r15
ffffffff80200bd2:	41 56                	push   %r14
ffffffff80200bd4:	41 55                	push   %r13
ffffffff80200bd6:	41 54                	push   %r12
ffffffff80200bd8:	55                   	push   %rbp
ffffffff80200bd9:	53                   	push   %rbx
ffffffff80200bda:	48 83 ec 08          	sub    $0x8,%rsp
ffffffff80200bde:	48 89 fb             	mov    %rdi,%rbx
ffffffff80200be1:	49 89 f5             	mov    %rsi,%r13
ffffffff80200be4:	49 89 d6             	mov    %rdx,%r14
    uint64_t last_physical_address = 0;
    clear_screen();
ffffffff80200be7:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80200bec:	e8 8a fc ff ff       	callq  ffffffff8020087b <clear_screen>
    struct smap_t {
        uint64_t base, length;
        uint32_t type;
    }__attribute__((packed)) *smap;
    while (modulep[0] != 0x9001) modulep += modulep[1] + 2;
ffffffff80200bf1:	81 3b 01 90 00 00    	cmpl   $0x9001,(%rbx)
ffffffff80200bf7:	74 12                	je     ffffffff80200c0b <start+0x3b>
ffffffff80200bf9:	8b 43 04             	mov    0x4(%rbx),%eax
ffffffff80200bfc:	8d 40 02             	lea    0x2(%rax),%eax
ffffffff80200bff:	48 8d 1c 83          	lea    (%rbx,%rax,4),%rbx
ffffffff80200c03:	81 3b 01 90 00 00    	cmpl   $0x9001,(%rbx)
ffffffff80200c09:	75 ee                	jne    ffffffff80200bf9 <start+0x29>
    for (smap = (struct smap_t*)(modulep + 2); smap < (struct smap_t*)((char*)modulep+modulep[1] + 2 * 4); ++smap) {
ffffffff80200c0b:	48 8d 6b 08          	lea    0x8(%rbx),%rbp
ffffffff80200c0f:	8b 43 04             	mov    0x4(%rbx),%eax
ffffffff80200c12:	48 8d 44 03 08       	lea    0x8(%rbx,%rax,1),%rax
ffffffff80200c17:	48 39 c5             	cmp    %rax,%rbp
ffffffff80200c1a:	73 61                	jae    ffffffff80200c7d <start+0xad>
ffffffff80200c1c:	41 bc 00 00 00 00    	mov    $0x0,%r12d
        if (smap->type == 1 /* memory */ && smap->length != 0) {
            kprintf("Available Physical Memory [%p-%p]\n", smap->base, smap->base + smap->length);
ffffffff80200c22:	4c 8d 3d 87 1e 00 00 	lea    0x1e87(%rip),%r15        # ffffffff80202ab0 <_x86_64_asm_ltr+0xc1b>
        uint64_t base, length;
        uint32_t type;
    }__attribute__((packed)) *smap;
    while (modulep[0] != 0x9001) modulep += modulep[1] + 2;
    for (smap = (struct smap_t*)(modulep + 2); smap < (struct smap_t*)((char*)modulep+modulep[1] + 2 * 4); ++smap) {
        if (smap->type == 1 /* memory */ && smap->length != 0) {
ffffffff80200c29:	83 7d 10 01          	cmpl   $0x1,0x10(%rbp)
ffffffff80200c2d:	75 3b                	jne    ffffffff80200c6a <start+0x9a>
ffffffff80200c2f:	48 8b 55 08          	mov    0x8(%rbp),%rdx
ffffffff80200c33:	48 85 d2             	test   %rdx,%rdx
ffffffff80200c36:	74 32                	je     ffffffff80200c6a <start+0x9a>
            kprintf("Available Physical Memory [%p-%p]\n", smap->base, smap->base + smap->length);
ffffffff80200c38:	48 8b 75 00          	mov    0x0(%rbp),%rsi
ffffffff80200c3c:	48 01 f2             	add    %rsi,%rdx
ffffffff80200c3f:	4c 89 ff             	mov    %r15,%rdi
ffffffff80200c42:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80200c47:	e8 99 f9 ff ff       	callq  ffffffff802005e5 <kprintf>
            page_init(smap->base, (smap->base + smap->length), (uint64_t)physbase, (uint64_t)physfree);
ffffffff80200c4c:	48 8b 7d 00          	mov    0x0(%rbp),%rdi
ffffffff80200c50:	48 89 fe             	mov    %rdi,%rsi
ffffffff80200c53:	48 03 75 08          	add    0x8(%rbp),%rsi
ffffffff80200c57:	4c 89 f1             	mov    %r14,%rcx
ffffffff80200c5a:	4c 89 ea             	mov    %r13,%rdx
ffffffff80200c5d:	e8 b5 f4 ff ff       	callq  ffffffff80200117 <page_init>
            last_physical_address = smap->base + smap->length;
ffffffff80200c62:	4c 8b 65 08          	mov    0x8(%rbp),%r12
ffffffff80200c66:	4c 03 65 00          	add    0x0(%rbp),%r12
    struct smap_t {
        uint64_t base, length;
        uint32_t type;
    }__attribute__((packed)) *smap;
    while (modulep[0] != 0x9001) modulep += modulep[1] + 2;
    for (smap = (struct smap_t*)(modulep + 2); smap < (struct smap_t*)((char*)modulep+modulep[1] + 2 * 4); ++smap) {
ffffffff80200c6a:	48 83 c5 14          	add    $0x14,%rbp
ffffffff80200c6e:	8b 43 04             	mov    0x4(%rbx),%eax
ffffffff80200c71:	48 8d 44 03 08       	lea    0x8(%rbx,%rax,1),%rax
ffffffff80200c76:	48 39 c5             	cmp    %rax,%rbp
ffffffff80200c79:	72 ae                	jb     ffffffff80200c29 <start+0x59>
ffffffff80200c7b:	eb 06                	jmp    ffffffff80200c83 <start+0xb3>
uint8_t initial_stack[INITIAL_STACK_SIZE]__attribute__((aligned(16)));
uint32_t* loader_stack;
extern char kernmem, physbase;

void start(uint32_t *modulep, void *physbase, void *physfree) {
    uint64_t last_physical_address = 0;
ffffffff80200c7d:	41 bc 00 00 00 00    	mov    $0x0,%r12d
            page_init(smap->base, (smap->base + smap->length), (uint64_t)physbase, (uint64_t)physfree);
            last_physical_address = smap->base + smap->length;
        }
    }

    kprintf("physbase %p\n", (uint64_t)physbase);
ffffffff80200c83:	4c 89 ee             	mov    %r13,%rsi
ffffffff80200c86:	48 8d 3d ad 12 00 00 	lea    0x12ad(%rip),%rdi        # ffffffff80201f3a <_x86_64_asm_ltr+0xa5>
ffffffff80200c8d:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80200c92:	e8 4e f9 ff ff       	callq  ffffffff802005e5 <kprintf>
    kprintf("physfree %p\n", (uint64_t)physfree);
ffffffff80200c97:	4c 89 f6             	mov    %r14,%rsi
ffffffff80200c9a:	48 8d 3d a6 12 00 00 	lea    0x12a6(%rip),%rdi        # ffffffff80201f47 <_x86_64_asm_ltr+0xb2>
ffffffff80200ca1:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80200ca6:	e8 3a f9 ff ff       	callq  ffffffff802005e5 <kprintf>
    kprintf("tarfs in [%p:%p]\n", &_binary_tarfs_start, &_binary_tarfs_end);
ffffffff80200cab:	48 8d 15 ee c8 08 00 	lea    0x8c8ee(%rip),%rdx        # ffffffff8028d5a0 <_binary_tarfs_end>
ffffffff80200cb2:	48 8d 35 e7 58 00 00 	lea    0x58e7(%rip),%rsi        # ffffffff802065a0 <_binary_tarfs_start>
ffffffff80200cb9:	48 8d 3d 94 12 00 00 	lea    0x1294(%rip),%rdi        # ffffffff80201f54 <_x86_64_asm_ltr+0xbf>
ffffffff80200cc0:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80200cc5:	e8 1b f9 ff ff       	callq  ffffffff802005e5 <kprintf>

    // Paging
    setup_page_tables((uint64_t)physbase, (uint64_t)physfree, last_physical_address);
ffffffff80200cca:	4c 89 e2             	mov    %r12,%rdx
ffffffff80200ccd:	4c 89 f6             	mov    %r14,%rsi
ffffffff80200cd0:	4c 89 ef             	mov    %r13,%rdi
ffffffff80200cd3:	e8 91 fe ff ff       	callq  ffffffff80200b69 <setup_page_tables>
    load_cr3();
ffffffff80200cd8:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80200cdd:	e8 23 fc ff ff       	callq  ffffffff80200905 <load_cr3>
    // Free initial pages (0 to physbase) used by the bootloader
    // deallocate_initial_pages((uint64_t)physbase);

    // kmalloc(20000000);
    // kprintf("Allocation works");
    create_threads();
ffffffff80200ce2:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80200ce7:	e8 9d 02 00 00       	callq  ffffffff80200f89 <create_threads>
    // init_pci();
}
ffffffff80200cec:	48 83 c4 08          	add    $0x8,%rsp
ffffffff80200cf0:	5b                   	pop    %rbx
ffffffff80200cf1:	5d                   	pop    %rbp
ffffffff80200cf2:	41 5c                	pop    %r12
ffffffff80200cf4:	41 5d                	pop    %r13
ffffffff80200cf6:	41 5e                	pop    %r14
ffffffff80200cf8:	41 5f                	pop    %r15
ffffffff80200cfa:	c3                   	retq   

ffffffff80200cfb <boot>:

void boot(void) {
    // note: function changes rsp, local stack variables can't be practically used
    register char *temp1;
    for(temp1 = (char*)0xb8001; temp1 < (char*)0xb8000+160*25; temp1 += 2) *temp1 = 7 /* white */;
ffffffff80200cfb:	b8 01 80 0b 00       	mov    $0xb8001,%eax
ffffffff80200d00:	c6 00 07             	movb   $0x7,(%rax)
ffffffff80200d03:	48 83 c0 02          	add    $0x2,%rax
ffffffff80200d07:	48 3d a1 8f 0b 00    	cmp    $0xb8fa1,%rax
ffffffff80200d0d:	75 f1                	jne    ffffffff80200d00 <boot+0x5>
    // kprintf("Allocation works");
    create_threads();
    // init_pci();
}

void boot(void) {
ffffffff80200d0f:	53                   	push   %rbx
    // note: function changes rsp, local stack variables can't be practically used
    register char *temp1;
    for(temp1 = (char*)0xb8001; temp1 < (char*)0xb8000+160*25; temp1 += 2) *temp1 = 7 /* white */;
    __asm__(
ffffffff80200d10:	48 8d 1d 09 36 00 00 	lea    0x3609(%rip),%rbx        # ffffffff80204320 <loader_stack>
ffffffff80200d17:	48 8d 05 12 36 00 00 	lea    0x3612(%rip),%rax        # ffffffff80204330 <initial_stack>
ffffffff80200d1e:	48 8d 80 00 10 00 00 	lea    0x1000(%rax),%rax
ffffffff80200d25:	fa                   	cli    
ffffffff80200d26:	48 89 23             	mov    %rsp,(%rbx)
ffffffff80200d29:	48 89 c4             	mov    %rax,%rsp
        "movq %%rsp, %0;"
        "movq %1, %%rsp;"
        :"=g"(loader_stack)
        :"r"(&initial_stack[INITIAL_STACK_SIZE])
    );
    init_gdt();
ffffffff80200d2c:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80200d31:	e8 a3 0f 00 00       	callq  ffffffff80201cd9 <init_gdt>
    init_idt();
ffffffff80200d36:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80200d3b:	e8 b0 02 00 00       	callq  ffffffff80200ff0 <init_idt>
    init_pic();
ffffffff80200d40:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80200d45:	e8 50 03 00 00       	callq  ffffffff8020109a <init_pic>

    start(
        (uint32_t*)((char*)(uint64_t)loader_stack[3] + (uint64_t)&kernmem - (uint64_t)&physbase),
        (uint64_t*)&physbase,
        (uint64_t*)(uint64_t)loader_stack[4]
ffffffff80200d4a:	48 8b 03             	mov    (%rbx),%rax
    );
    init_gdt();
    init_idt();
    init_pic();

    start(
ffffffff80200d4d:	8b 50 10             	mov    0x10(%rax),%edx
ffffffff80200d50:	48 8b 35 a9 22 00 00 	mov    0x22a9(%rip),%rsi        # ffffffff80203000 <_x86_64_asm_ltr+0x116b>
ffffffff80200d57:	48 8b 3d aa 22 00 00 	mov    0x22aa(%rip),%rdi        # ffffffff80203008 <_x86_64_asm_ltr+0x1173>
ffffffff80200d5e:	48 29 f7             	sub    %rsi,%rdi
ffffffff80200d61:	8b 40 0c             	mov    0xc(%rax),%eax
ffffffff80200d64:	48 01 c7             	add    %rax,%rdi
ffffffff80200d67:	e8 64 fe ff ff       	callq  ffffffff80200bd0 <start>
        (uint32_t*)((char*)(uint64_t)loader_stack[3] + (uint64_t)&kernmem - (uint64_t)&physbase),
        (uint64_t*)&physbase,
        (uint64_t*)(uint64_t)loader_stack[4]
    );

    while(1) __asm__ volatile ("hlt");
ffffffff80200d6c:	f4                   	hlt    
ffffffff80200d6d:	eb fd                	jmp    ffffffff80200d6c <boot+0x71>

ffffffff80200d6f <get_process_id>:
task_struct *next;

int get_process_id() {
    int i;
    for (i = 0; i < MAX_PROCESS; i++) {
        if (process_ids[i] == 0) {
ffffffff80200d6f:	48 8d 05 4a 35 00 00 	lea    0x354a(%rip),%rax        # ffffffff802042c0 <process_ids>
ffffffff80200d76:	83 38 00             	cmpl   $0x0,(%rax)
ffffffff80200d79:	74 10                	je     ffffffff80200d8b <get_process_id+0x1c>
ffffffff80200d7b:	48 8d 50 04          	lea    0x4(%rax),%rdx

task_struct *next;

int get_process_id() {
    int i;
    for (i = 0; i < MAX_PROCESS; i++) {
ffffffff80200d7f:	b8 01 00 00 00       	mov    $0x1,%eax
        if (process_ids[i] == 0) {
ffffffff80200d84:	83 3a 00             	cmpl   $0x0,(%rdx)
ffffffff80200d87:	75 19                	jne    ffffffff80200da2 <get_process_id+0x33>
ffffffff80200d89:	eb 05                	jmp    ffffffff80200d90 <get_process_id+0x21>

task_struct *next;

int get_process_id() {
    int i;
    for (i = 0; i < MAX_PROCESS; i++) {
ffffffff80200d8b:	b8 00 00 00 00       	mov    $0x0,%eax
        if (process_ids[i] == 0) {
            process_ids[i] = 1;
ffffffff80200d90:	48 63 c8             	movslq %eax,%rcx
ffffffff80200d93:	48 8d 15 26 35 00 00 	lea    0x3526(%rip),%rdx        # ffffffff802042c0 <process_ids>
ffffffff80200d9a:	c7 04 8a 01 00 00 00 	movl   $0x1,(%rdx,%rcx,4)
            return i;
ffffffff80200da1:	c3                   	retq   

task_struct *next;

int get_process_id() {
    int i;
    for (i = 0; i < MAX_PROCESS; i++) {
ffffffff80200da2:	ff c0                	inc    %eax
ffffffff80200da4:	48 83 c2 04          	add    $0x4,%rdx
ffffffff80200da8:	83 f8 0a             	cmp    $0xa,%eax
ffffffff80200dab:	75 d7                	jne    ffffffff80200d84 <get_process_id+0x15>
        if (process_ids[i] == 0) {
            process_ids[i] = 1;
            return i;
        }
    }
    return -1;
ffffffff80200dad:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
ffffffff80200db2:	c3                   	retq   

ffffffff80200db3 <thread1>:
    //     x++;
    //     // write(0, "Ring3", 6);
    // }
}

void thread1() {
ffffffff80200db3:	53                   	push   %rbx
    uint64_t rsp;
    task_struct *pcb = kmalloc(sizeof(task_struct));
ffffffff80200db4:	bf 30 10 00 00       	mov    $0x1030,%edi
ffffffff80200db9:	e8 be fd ff ff       	callq  ffffffff80200b7c <kmalloc>
ffffffff80200dbe:	48 89 c3             	mov    %rax,%rbx
    pcb->pid = get_process_id();
ffffffff80200dc1:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80200dc6:	e8 a4 ff ff ff       	callq  ffffffff80200d6f <get_process_id>
ffffffff80200dcb:	48 98                	cltq   
ffffffff80200dcd:	48 89 83 08 10 00 00 	mov    %rax,0x1008(%rbx)
    pcb->rip = (uint64_t)process1;
ffffffff80200dd4:	48 8d 05 53 00 00 00 	lea    0x53(%rip),%rax        # ffffffff80200e2e <process1>
ffffffff80200ddb:	48 89 83 28 10 00 00 	mov    %rax,0x1028(%rbx)
    __asm__ volatile(
ffffffff80200de2:	48 89 e7             	mov    %rsp,%rdi
        "movq %%rsp, %0;"
        :"=r" (rsp)
    );
    set_tss_rsp((uint64_t *)rsp);
ffffffff80200de5:	e8 7d 0f 00 00       	callq  ffffffff80201d67 <set_tss_rsp>
    next = current;
ffffffff80200dea:	48 8d 05 f7 34 00 00 	lea    0x34f7(%rip),%rax        # ffffffff802042e8 <current>
ffffffff80200df1:	48 8b 08             	mov    (%rax),%rcx
ffffffff80200df4:	48 8d 15 35 45 00 00 	lea    0x4535(%rip),%rdx        # ffffffff80205330 <next>
ffffffff80200dfb:	48 89 0a             	mov    %rcx,(%rdx)
    current = pcb;
ffffffff80200dfe:	48 89 18             	mov    %rbx,(%rax)
    _switch_to_ring_3(pcb->rip);
ffffffff80200e01:	48 8b bb 28 10 00 00 	mov    0x1028(%rbx),%rdi
ffffffff80200e08:	e8 62 0f 00 00       	callq  ffffffff80201d6f <_switch_to_ring_3>
}
ffffffff80200e0d:	5b                   	pop    %rbx
ffffffff80200e0e:	c3                   	retq   

ffffffff80200e0f <write>:
        }
    }
    return -1;
}

ssize_t write(int fd, const void *buf, size_t count) {
ffffffff80200e0f:	48 89 f1             	mov    %rsi,%rcx
ffffffff80200e12:	49 89 d1             	mov    %rdx,%r9
    ssize_t num_bytes;

    __asm__ __volatile__(
ffffffff80200e15:	4c 63 c7             	movslq %edi,%r8
ffffffff80200e18:	48 c7 c0 01 00 00 00 	mov    $0x1,%rax
ffffffff80200e1f:	4c 89 c7             	mov    %r8,%rdi
ffffffff80200e22:	48 89 ce             	mov    %rcx,%rsi
ffffffff80200e25:	4c 89 ca             	mov    %r9,%rdx
ffffffff80200e28:	cd 80                	int    $0x80
        : "r" ((int64_t)fd), "r" (buf), "r" (count)
        : "%rax", "%rdi", "%rsi", "%rdx"
    );

    return num_bytes;
}
ffffffff80200e2a:	48 89 c8             	mov    %rcx,%rax
ffffffff80200e2d:	c3                   	retq   

ffffffff80200e2e <process1>:
    scheduler();
    _context_switch(current, next);
}

int x = 9;
void process1() {
ffffffff80200e2e:	48 83 ec 08          	sub    $0x8,%rsp
    int y = write(0, "Ring3", 6);
ffffffff80200e32:	ba 06 00 00 00       	mov    $0x6,%edx
ffffffff80200e37:	48 8d 35 28 11 00 00 	lea    0x1128(%rip),%rsi        # ffffffff80201f66 <_x86_64_asm_ltr+0xd1>
ffffffff80200e3e:	bf 00 00 00 00       	mov    $0x0,%edi
ffffffff80200e43:	e8 c7 ff ff ff       	callq  ffffffff80200e0f <write>
ffffffff80200e48:	eb fe                	jmp    ffffffff80200e48 <process1+0x1a>

ffffffff80200e4a <scheduler>:
}


/* Pick the first task from the list and put suspended task at the end of the list */
void scheduler() {
    current = process_list_head;
ffffffff80200e4a:	48 8d 0d a7 34 00 00 	lea    0x34a7(%rip),%rcx        # ffffffff802042f8 <process_list_head>
ffffffff80200e51:	48 8b 01             	mov    (%rcx),%rax
ffffffff80200e54:	48 8d 15 8d 34 00 00 	lea    0x348d(%rip),%rdx        # ffffffff802042e8 <current>
ffffffff80200e5b:	48 89 02             	mov    %rax,(%rdx)
    next = process_list_head->next;
ffffffff80200e5e:	48 8b b0 20 10 00 00 	mov    0x1020(%rax),%rsi
ffffffff80200e65:	48 8d 15 c4 44 00 00 	lea    0x44c4(%rip),%rdx        # ffffffff80205330 <next>
ffffffff80200e6c:	48 89 32             	mov    %rsi,(%rdx)
    process_list_tail->next = current;
ffffffff80200e6f:	48 8d 15 7a 34 00 00 	lea    0x347a(%rip),%rdx        # ffffffff802042f0 <process_list_tail>
ffffffff80200e76:	48 8b 3a             	mov    (%rdx),%rdi
ffffffff80200e79:	48 89 87 20 10 00 00 	mov    %rax,0x1020(%rdi)
    current->next = NULL;
ffffffff80200e80:	48 c7 80 20 10 00 00 	movq   $0x0,0x1020(%rax)
ffffffff80200e87:	00 00 00 00 
    process_list_head = next;
ffffffff80200e8b:	48 89 31             	mov    %rsi,(%rcx)
    process_list_tail = current;
ffffffff80200e8e:	48 89 02             	mov    %rax,(%rdx)
ffffffff80200e91:	c3                   	retq   

ffffffff80200e92 <yield>:
}

void yield() {
ffffffff80200e92:	48 83 ec 08          	sub    $0x8,%rsp
    scheduler();
ffffffff80200e96:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80200e9b:	e8 aa ff ff ff       	callq  ffffffff80200e4a <scheduler>
    _context_switch(current, next);
ffffffff80200ea0:	48 8d 05 89 44 00 00 	lea    0x4489(%rip),%rax        # ffffffff80205330 <next>
ffffffff80200ea7:	48 8b 30             	mov    (%rax),%rsi
ffffffff80200eaa:	48 8d 05 37 34 00 00 	lea    0x3437(%rip),%rax        # ffffffff802042e8 <current>
ffffffff80200eb1:	48 8b 38             	mov    (%rax),%rdi
ffffffff80200eb4:	e8 7c 0f 00 00       	callq  ffffffff80201e35 <_context_switch>
}
ffffffff80200eb9:	48 83 c4 08          	add    $0x8,%rsp
ffffffff80200ebd:	c3                   	retq   

ffffffff80200ebe <thread2>:
    next = current;
    current = pcb;
    _switch_to_ring_3(pcb->rip);
}

void thread2() {
ffffffff80200ebe:	55                   	push   %rbp
ffffffff80200ebf:	53                   	push   %rbx
ffffffff80200ec0:	48 83 ec 08          	sub    $0x8,%rsp
    uint64_t j = 1000;
ffffffff80200ec4:	bb e8 03 00 00       	mov    $0x3e8,%ebx
    while (1) {
        j++;
        kprintf("Thread B %d\n", j);
ffffffff80200ec9:	48 8d 2d 9c 10 00 00 	lea    0x109c(%rip),%rbp        # ffffffff80201f6c <_x86_64_asm_ltr+0xd7>
}

void thread2() {
    uint64_t j = 1000;
    while (1) {
        j++;
ffffffff80200ed0:	48 ff c3             	inc    %rbx
        kprintf("Thread B %d\n", j);
ffffffff80200ed3:	48 89 de             	mov    %rbx,%rsi
ffffffff80200ed6:	48 89 ef             	mov    %rbp,%rdi
ffffffff80200ed9:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80200ede:	e8 02 f7 ff ff       	callq  ffffffff802005e5 <kprintf>
        yield();
ffffffff80200ee3:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80200ee8:	e8 a5 ff ff ff       	callq  ffffffff80200e92 <yield>
ffffffff80200eed:	eb e1                	jmp    ffffffff80200ed0 <thread2+0x12>

ffffffff80200eef <add_process>:
    }
}

/* Add process to the end of the process list */
void add_process(task_struct *pcb) {
    if (process_list_head == NULL) {
ffffffff80200eef:	48 8d 05 02 34 00 00 	lea    0x3402(%rip),%rax        # ffffffff802042f8 <process_list_head>
ffffffff80200ef6:	48 83 38 00          	cmpq   $0x0,(%rax)
ffffffff80200efa:	75 03                	jne    ffffffff80200eff <add_process+0x10>
        process_list_head = pcb;
ffffffff80200efc:	48 89 38             	mov    %rdi,(%rax)
    }

    if (process_list_tail == NULL) {
ffffffff80200eff:	48 8d 05 ea 33 00 00 	lea    0x33ea(%rip),%rax        # ffffffff802042f0 <process_list_tail>
ffffffff80200f06:	48 8b 00             	mov    (%rax),%rax
ffffffff80200f09:	48 85 c0             	test   %rax,%rax
ffffffff80200f0c:	75 0b                	jne    ffffffff80200f19 <add_process+0x2a>
        process_list_tail = pcb;
ffffffff80200f0e:	48 8d 05 db 33 00 00 	lea    0x33db(%rip),%rax        # ffffffff802042f0 <process_list_tail>
ffffffff80200f15:	48 89 38             	mov    %rdi,(%rax)
ffffffff80200f18:	c3                   	retq   
    } else {
        process_list_tail->next = pcb;
ffffffff80200f19:	48 89 b8 20 10 00 00 	mov    %rdi,0x1020(%rax)
        process_list_tail = pcb;
ffffffff80200f20:	48 8d 05 c9 33 00 00 	lea    0x33c9(%rip),%rax        # ffffffff802042f0 <process_list_tail>
ffffffff80200f27:	48 89 38             	mov    %rdi,(%rax)
ffffffff80200f2a:	c3                   	retq   

ffffffff80200f2b <create_thread>:
    }
}

/* Create thread by setting up stack and rsp */
task_struct *create_thread(void *thread) {
ffffffff80200f2b:	55                   	push   %rbp
ffffffff80200f2c:	53                   	push   %rbx
ffffffff80200f2d:	48 83 ec 08          	sub    $0x8,%rsp
ffffffff80200f31:	48 89 fd             	mov    %rdi,%rbp
    task_struct *pcb = kmalloc(sizeof(task_struct));
ffffffff80200f34:	bf 30 10 00 00       	mov    $0x1030,%edi
ffffffff80200f39:	e8 3e fc ff ff       	callq  ffffffff80200b7c <kmalloc>
ffffffff80200f3e:	48 89 c3             	mov    %rax,%rbx
    pcb->pid = get_process_id();
ffffffff80200f41:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80200f46:	e8 24 fe ff ff       	callq  ffffffff80200d6f <get_process_id>
ffffffff80200f4b:	48 98                	cltq   
ffffffff80200f4d:	48 89 83 08 10 00 00 	mov    %rax,0x1008(%rbx)
    *((uint64_t *)&pcb->kstack[4088]) = (uint64_t)thread; // Push Return address
ffffffff80200f54:	48 89 ab 00 10 00 00 	mov    %rbp,0x1000(%rbx)
    /* Stack entries from 3984 to 4080 are reserved for 13 registers pushed/poped in context_switch.s */
    *((uint64_t *)&pcb->kstack[3976]) = (uint64_t)pcb;    // Push PCB
ffffffff80200f5b:	48 89 9b 90 0f 00 00 	mov    %rbx,0xf90(%rbx)
    pcb->rsp = (uint64_t)&pcb->kstack[3976];
ffffffff80200f62:	48 8d 83 90 0f 00 00 	lea    0xf90(%rbx),%rax
ffffffff80200f69:	48 89 03             	mov    %rax,(%rbx)
    pcb->next = NULL;
ffffffff80200f6c:	48 c7 83 20 10 00 00 	movq   $0x0,0x1020(%rbx)
ffffffff80200f73:	00 00 00 00 
    add_process(pcb);
ffffffff80200f77:	48 89 df             	mov    %rbx,%rdi
ffffffff80200f7a:	e8 70 ff ff ff       	callq  ffffffff80200eef <add_process>

    return pcb;
}
ffffffff80200f7f:	48 89 d8             	mov    %rbx,%rax
ffffffff80200f82:	48 83 c4 08          	add    $0x8,%rsp
ffffffff80200f86:	5b                   	pop    %rbx
ffffffff80200f87:	5d                   	pop    %rbp
ffffffff80200f88:	c3                   	retq   

ffffffff80200f89 <create_threads>:

/* Switch 2 new threads (thread1, thread 2) and switch from current thread to thread 1 */
void create_threads() {
ffffffff80200f89:	55                   	push   %rbp
ffffffff80200f8a:	53                   	push   %rbx
ffffffff80200f8b:	48 83 ec 08          	sub    $0x8,%rsp
    task_struct *pcb0 = kmalloc(sizeof(task_struct));
ffffffff80200f8f:	bf 30 10 00 00       	mov    $0x1030,%edi
ffffffff80200f94:	e8 e3 fb ff ff       	callq  ffffffff80200b7c <kmalloc>
ffffffff80200f99:	48 89 c3             	mov    %rax,%rbx
    task_struct *pcb1 = create_thread(thread1);
ffffffff80200f9c:	48 8d 3d 10 fe ff ff 	lea    -0x1f0(%rip),%rdi        # ffffffff80200db3 <thread1>
ffffffff80200fa3:	e8 83 ff ff ff       	callq  ffffffff80200f2b <create_thread>
ffffffff80200fa8:	48 89 c5             	mov    %rax,%rbp
    create_thread(thread2);
ffffffff80200fab:	48 8d 3d 0c ff ff ff 	lea    -0xf4(%rip),%rdi        # ffffffff80200ebe <thread2>
ffffffff80200fb2:	e8 74 ff ff ff       	callq  ffffffff80200f2b <create_thread>
    _context_switch(pcb0, pcb1);
ffffffff80200fb7:	48 89 ee             	mov    %rbp,%rsi
ffffffff80200fba:	48 89 df             	mov    %rbx,%rdi
ffffffff80200fbd:	e8 73 0e 00 00       	callq  ffffffff80201e35 <_context_switch>
}
ffffffff80200fc2:	48 83 c4 08          	add    $0x8,%rsp
ffffffff80200fc6:	5b                   	pop    %rbx
ffffffff80200fc7:	5d                   	pop    %rbp
ffffffff80200fc8:	c3                   	retq   

ffffffff80200fc9 <set_idt>:

void _x86_64_asm_lidt(IDT_ptr *idt_ptr);

// Set properties of IDT entry
void set_idt(int num, uint64_t base, uint8_t type_attr) {
    idt[num].type_attr = type_attr;
ffffffff80200fc9:	48 63 ff             	movslq %edi,%rdi
ffffffff80200fcc:	48 c1 e7 04          	shl    $0x4,%rdi
ffffffff80200fd0:	48 81 c7 60 53 20 80 	add    $0xffffffff80205360,%rdi
ffffffff80200fd7:	88 57 05             	mov    %dl,0x5(%rdi)
    idt[num].offset_1 = base & 0xFFFF;
ffffffff80200fda:	66 89 37             	mov    %si,(%rdi)
    idt[num].offset_2 = (base >> 16) & 0xFFFF;
ffffffff80200fdd:	48 89 f0             	mov    %rsi,%rax
ffffffff80200fe0:	48 c1 e8 10          	shr    $0x10,%rax
ffffffff80200fe4:	66 89 47 06          	mov    %ax,0x6(%rdi)
    idt[num].offset_3 = (base >> 32) & 0xFFFFFFFF;
ffffffff80200fe8:	48 c1 ee 20          	shr    $0x20,%rsi
ffffffff80200fec:	89 77 08             	mov    %esi,0x8(%rdi)
ffffffff80200fef:	c3                   	retq   

ffffffff80200ff0 <init_idt>:
}

void init_idt() {
ffffffff80200ff0:	55                   	push   %rbp
ffffffff80200ff1:	53                   	push   %rbx
ffffffff80200ff2:	48 83 ec 08          	sub    $0x8,%rsp
    int i, type_attr;
    idt_ptr.limit = sizeof(IDT) * 256 - 1; // Size of the table - 1
ffffffff80200ff6:	48 8d 3d 43 43 00 00 	lea    0x4343(%rip),%rdi        # ffffffff80205340 <idt_ptr>
ffffffff80200ffd:	66 c7 07 ff 0f       	movw   $0xfff,(%rdi)
    idt_ptr.base = (uint64_t)&idt; // Virtual address of the table
ffffffff80201002:	48 8d 1d 57 43 00 00 	lea    0x4357(%rip),%rbx        # ffffffff80205360 <idt>
ffffffff80201009:	48 89 5f 02          	mov    %rbx,0x2(%rdi)

    // Load IDT
    _x86_64_asm_lidt(&idt_ptr);
ffffffff8020100d:	e8 5d 0e 00 00       	callq  ffffffff80201e6f <_x86_64_asm_lidt>
ffffffff80201012:	48 8d 43 04          	lea    0x4(%rbx),%rax
ffffffff80201016:	48 8d 93 04 10 00 00 	lea    0x1004(%rbx),%rdx

    for (i = 0; i < SIZE; i++) {
        // Single kernel stack
        idt[i].ist = 0x00;
ffffffff8020101d:	c6 00 00             	movb   $0x0,(%rax)

        // target ring (RPL) = 0, GDT = 0 and index  = 1
        idt[i].selector = 0x08;
ffffffff80201020:	66 c7 40 fe 08 00    	movw   $0x8,-0x2(%rax)
ffffffff80201026:	48 83 c0 10          	add    $0x10,%rax
    idt_ptr.base = (uint64_t)&idt; // Virtual address of the table

    // Load IDT
    _x86_64_asm_lidt(&idt_ptr);

    for (i = 0; i < SIZE; i++) {
ffffffff8020102a:	48 39 d0             	cmp    %rdx,%rax
ffffffff8020102d:	75 ee                	jne    ffffffff8020101d <init_idt+0x2d>
ffffffff8020102f:	bb 00 00 00 00       	mov    $0x0,%ebx
    // 32-bit Interrupt gate: 0x8E (P=1, DPL=00b, S=0, type=1110b => type_attr=1000_1110b=0x8E)
    type_attr = 0x8E;

    // CPU exceptions
    for (i = 0; i < 32; i++)
        set_idt(i, (uint64_t)isr0, type_attr);
ffffffff80201034:	48 8d 2d 72 0d 00 00 	lea    0xd72(%rip),%rbp        # ffffffff80201dad <isr0>
ffffffff8020103b:	ba 8e 00 00 00       	mov    $0x8e,%edx
ffffffff80201040:	48 89 ee             	mov    %rbp,%rsi
ffffffff80201043:	89 df                	mov    %ebx,%edi
ffffffff80201045:	e8 7f ff ff ff       	callq  ffffffff80200fc9 <set_idt>

    // 32-bit Interrupt gate: 0x8E (P=1, DPL=00b, S=0, type=1110b => type_attr=1000_1110b=0x8E)
    type_attr = 0x8E;

    // CPU exceptions
    for (i = 0; i < 32; i++)
ffffffff8020104a:	ff c3                	inc    %ebx
ffffffff8020104c:	83 fb 20             	cmp    $0x20,%ebx
ffffffff8020104f:	75 ea                	jne    ffffffff8020103b <init_idt+0x4b>
        set_idt(i, (uint64_t)isr0, type_attr);

    // Timer Interrupt
    set_idt(0x20, (uint64_t)isr32, type_attr);
ffffffff80201051:	ba 8e 00 00 00       	mov    $0x8e,%edx
ffffffff80201056:	48 8d 35 72 0d 00 00 	lea    0xd72(%rip),%rsi        # ffffffff80201dcf <isr32>
ffffffff8020105d:	bf 20 00 00 00       	mov    $0x20,%edi
ffffffff80201062:	e8 62 ff ff ff       	callq  ffffffff80200fc9 <set_idt>

    // Keyboard Interrupt
    set_idt(0x21, (uint64_t)isr33, type_attr);
ffffffff80201067:	ba 8e 00 00 00       	mov    $0x8e,%edx
ffffffff8020106c:	48 8d 35 7e 0d 00 00 	lea    0xd7e(%rip),%rsi        # ffffffff80201df1 <isr33>
ffffffff80201073:	bf 21 00 00 00       	mov    $0x21,%edi
ffffffff80201078:	e8 4c ff ff ff       	callq  ffffffff80200fc9 <set_idt>

    // 32-bit Interrupt gate: 0x8E (P=1, DPL=11b, S=0, type=1110b => type_attr=1110_1110b=0x8E)
    type_attr = 0xEE;

    set_idt(0x80, (uint64_t)isr128, type_attr);
ffffffff8020107d:	ba ee 00 00 00       	mov    $0xee,%edx
ffffffff80201082:	48 8d 35 8a 0d 00 00 	lea    0xd8a(%rip),%rsi        # ffffffff80201e13 <isr128>
ffffffff80201089:	bf 80 00 00 00       	mov    $0x80,%edi
ffffffff8020108e:	e8 36 ff ff ff       	callq  ffffffff80200fc9 <set_idt>
  
}
ffffffff80201093:	48 83 c4 08          	add    $0x8,%rsp
ffffffff80201097:	5b                   	pop    %rbx
ffffffff80201098:	5d                   	pop    %rbp
ffffffff80201099:	c3                   	retq   

ffffffff8020109a <init_pic>:
void _x86_64_asm_pic_remapping();

void init_pic() {
ffffffff8020109a:	48 83 ec 08          	sub    $0x8,%rsp
    _x86_64_asm_pic_remapping();
ffffffff8020109e:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff802010a3:	e8 e7 0c 00 00       	callq  ffffffff80201d8f <_x86_64_asm_pic_remapping>
}
ffffffff802010a8:	48 83 c4 08          	add    $0x8,%rsp
ffffffff802010ac:	c3                   	retq   
ffffffff802010ad:	0f 1f 00             	nopl   (%rax)

ffffffff802010b0 <shift_key>:
};

int control = 0, shift = 0;

int shift_key(int scancode) {
    if (scancode == LEFT_SHIFT_SC || scancode == RIGHT_SHIFT_SC) {
ffffffff802010b0:	83 ff 2a             	cmp    $0x2a,%edi
ffffffff802010b3:	74 0a                	je     ffffffff802010bf <shift_key+0xf>
        shift = 1;
        return 1;
    }

    return 0;
ffffffff802010b5:	b8 00 00 00 00       	mov    $0x0,%eax
};

int control = 0, shift = 0;

int shift_key(int scancode) {
    if (scancode == LEFT_SHIFT_SC || scancode == RIGHT_SHIFT_SC) {
ffffffff802010ba:	83 ff 36             	cmp    $0x36,%edi
ffffffff802010bd:	75 12                	jne    ffffffff802010d1 <shift_key+0x21>
        shift = 1;
ffffffff802010bf:	48 8d 05 5e 31 00 00 	lea    0x315e(%rip),%rax        # ffffffff80204224 <shift>
ffffffff802010c6:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
        return 1;
ffffffff802010cc:	b8 01 00 00 00       	mov    $0x1,%eax
    }

    return 0;
}
ffffffff802010d1:	f3 c3                	repz retq 

ffffffff802010d3 <control_key>:
    if (scancode == CONTROL_SC) {
        control = 1;
        return 1;
    }

    return 0;
ffffffff802010d3:	b8 00 00 00 00       	mov    $0x0,%eax

    return 0;
}

int control_key(int scancode) {
    if (scancode == CONTROL_SC) {
ffffffff802010d8:	83 ff 1d             	cmp    $0x1d,%edi
ffffffff802010db:	75 12                	jne    ffffffff802010ef <control_key+0x1c>
        control = 1;
ffffffff802010dd:	48 8d 05 44 31 00 00 	lea    0x3144(%rip),%rax        # ffffffff80204228 <control>
ffffffff802010e4:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
        return 1;
ffffffff802010ea:	b8 01 00 00 00       	mov    $0x1,%eax
    }

    return 0;
}
ffffffff802010ef:	f3 c3                	repz retq 

ffffffff802010f1 <keyboard_interrupt>:

void keyboard_interrupt() {
ffffffff802010f1:	53                   	push   %rbx
    int scancode = inb(0x60);
ffffffff802010f2:	bf 60 00 00 00       	mov    $0x60,%edi
ffffffff802010f7:	e8 b4 f7 ff ff       	callq  ffffffff802008b0 <inb>
ffffffff802010fc:	0f b6 d8             	movzbl %al,%ebx
    char ch1 = 0, ch2 = 0;

    // If a key is pressed
    if (scancode < SIZE) {
ffffffff802010ff:	83 fb 7f             	cmp    $0x7f,%ebx
ffffffff80201102:	0f 8f b2 00 00 00    	jg     ffffffff802011ba <keyboard_interrupt+0xc9>
        if (shift_key(scancode)) { // If a shift key is pressed
ffffffff80201108:	89 df                	mov    %ebx,%edi
ffffffff8020110a:	e8 a1 ff ff ff       	callq  ffffffff802010b0 <shift_key>
ffffffff8020110f:	85 c0                	test   %eax,%eax
ffffffff80201111:	0f 85 a3 00 00 00    	jne    ffffffff802011ba <keyboard_interrupt+0xc9>
            return;
        } else if (control_key(scancode)) { // If a control key is pressed
ffffffff80201117:	89 df                	mov    %ebx,%edi
ffffffff80201119:	e8 b5 ff ff ff       	callq  ffffffff802010d3 <control_key>
ffffffff8020111e:	85 c0                	test   %eax,%eax
ffffffff80201120:	0f 85 94 00 00 00    	jne    ffffffff802011ba <keyboard_interrupt+0xc9>
            return;
        } else if (shift == 1) { // If a shift key was pressed
ffffffff80201126:	48 8d 05 f7 30 00 00 	lea    0x30f7(%rip),%rax        # ffffffff80204224 <shift>
ffffffff8020112d:	83 38 01             	cmpl   $0x1,(%rax)
ffffffff80201130:	75 23                	jne    ffffffff80201155 <keyboard_interrupt+0x64>
            ch1 = scancode_ascii_shift[scancode];
ffffffff80201132:	48 63 db             	movslq %ebx,%rbx
ffffffff80201135:	48 8d 05 64 52 00 00 	lea    0x5264(%rip),%rax        # ffffffff802063a0 <scancode_ascii_shift>
ffffffff8020113c:	0f b6 0c 18          	movzbl (%rax,%rbx,1),%ecx
            shift = 0;
ffffffff80201140:	48 8d 05 dd 30 00 00 	lea    0x30dd(%rip),%rax        # ffffffff80204224 <shift>
ffffffff80201147:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
    return 0;
}

void keyboard_interrupt() {
    int scancode = inb(0x60);
    char ch1 = 0, ch2 = 0;
ffffffff8020114d:	41 b8 00 00 00 00    	mov    $0x0,%r8d
ffffffff80201153:	eb 43                	jmp    ffffffff80201198 <keyboard_interrupt+0xa7>
        } else if (control_key(scancode)) { // If a control key is pressed
            return;
        } else if (shift == 1) { // If a shift key was pressed
            ch1 = scancode_ascii_shift[scancode];
            shift = 0;
        } else if (control == 1) { // If a control key was pressed
ffffffff80201155:	48 8d 05 cc 30 00 00 	lea    0x30cc(%rip),%rax        # ffffffff80204228 <control>
ffffffff8020115c:	83 38 01             	cmpl   $0x1,(%rax)
ffffffff8020115f:	75 23                	jne    ffffffff80201184 <keyboard_interrupt+0x93>
            ch1 = '^';
            ch2 = scancode_ascii_shift[scancode];
ffffffff80201161:	48 63 db             	movslq %ebx,%rbx
ffffffff80201164:	48 8d 05 35 52 00 00 	lea    0x5235(%rip),%rax        # ffffffff802063a0 <scancode_ascii_shift>
ffffffff8020116b:	44 0f b6 04 18       	movzbl (%rax,%rbx,1),%r8d
            control = 0;
ffffffff80201170:	48 8d 05 b1 30 00 00 	lea    0x30b1(%rip),%rax        # ffffffff80204228 <control>
ffffffff80201177:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
            return;
        } else if (shift == 1) { // If a shift key was pressed
            ch1 = scancode_ascii_shift[scancode];
            shift = 0;
        } else if (control == 1) { // If a control key was pressed
            ch1 = '^';
ffffffff8020117d:	b9 5e 00 00 00       	mov    $0x5e,%ecx
ffffffff80201182:	eb 14                	jmp    ffffffff80201198 <keyboard_interrupt+0xa7>
            ch2 = scancode_ascii_shift[scancode];
            control = 0;
        } else {
            ch1 = scancode_ascii[scancode];
ffffffff80201184:	48 63 db             	movslq %ebx,%rbx
ffffffff80201187:	48 8d 05 92 52 00 00 	lea    0x5292(%rip),%rax        # ffffffff80206420 <scancode_ascii>
ffffffff8020118e:	0f b6 0c 18          	movzbl (%rax,%rbx,1),%ecx
    return 0;
}

void keyboard_interrupt() {
    int scancode = inb(0x60);
    char ch1 = 0, ch2 = 0;
ffffffff80201192:	41 b8 00 00 00 00    	mov    $0x0,%r8d
            control = 0;
        } else {
            ch1 = scancode_ascii[scancode];
        }

        kprintf_pos(ROW, COLUMN, "Last pressed glyph: %c%c", ch1, ch2);
ffffffff80201198:	0f be c9             	movsbl %cl,%ecx
ffffffff8020119b:	45 0f be c0          	movsbl %r8b,%r8d
ffffffff8020119f:	48 8d 15 d3 0d 00 00 	lea    0xdd3(%rip),%rdx        # ffffffff80201f79 <_x86_64_asm_ltr+0xe4>
ffffffff802011a6:	be 37 00 00 00       	mov    $0x37,%esi
ffffffff802011ab:	bf 18 00 00 00       	mov    $0x18,%edi
ffffffff802011b0:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff802011b5:	e8 3e f6 ff ff       	callq  ffffffff802007f8 <kprintf_pos>
    }
}
ffffffff802011ba:	5b                   	pop    %rbx
ffffffff802011bb:	c3                   	retq   

ffffffff802011bc <delay>:

// AHCI Base Memory Register
hba_mem_t *abar;

// Add a delay
void delay() {
ffffffff802011bc:	b8 40 42 0f 00       	mov    $0xf4240,%eax
    int spin = 0;

    while (spin < 1000000) {
ffffffff802011c1:	ff c8                	dec    %eax
ffffffff802011c3:	75 fc                	jne    ffffffff802011c1 <delay+0x5>
        spin++;
    }
}
ffffffff802011c5:	f3 c3                	repz retq 

ffffffff802011c7 <find_cmdslot>:

// Find a free command list slot
int find_cmdslot(hba_port_t *port) {
ffffffff802011c7:	48 83 ec 08          	sub    $0x8,%rsp
    // Check device status (DS) and command issue (CI) for each command slot status. If SACT and CI is not set, the slot is free.
    uint32_t slots = (port->sact | port->ci);
ffffffff802011cb:	8b 57 34             	mov    0x34(%rdi),%edx
ffffffff802011ce:	8b 47 38             	mov    0x38(%rdi),%eax
ffffffff802011d1:	09 c2                	or     %eax,%edx
    int i;

    // Bit 12:08 - Number of command slots (1 to 32 maximum)
    uint8_t num_slots = (abar->cap >> 8) & 0x1F;
ffffffff802011d3:	48 8d 05 86 51 00 00 	lea    0x5186(%rip),%rax        # ffffffff80206360 <abar>
ffffffff802011da:	48 8b 00             	mov    (%rax),%rax
ffffffff802011dd:	8b 08                	mov    (%rax),%ecx

    for (i = 0; i < num_slots; i++) {
ffffffff802011df:	c1 e9 08             	shr    $0x8,%ecx
ffffffff802011e2:	83 e1 1f             	and    $0x1f,%ecx
ffffffff802011e5:	74 19                	je     ffffffff80201200 <find_cmdslot+0x39>
        if ((slots & 1) == 0)
ffffffff802011e7:	f6 c2 01             	test   $0x1,%dl
ffffffff802011ea:	74 2c                	je     ffffffff80201218 <find_cmdslot+0x51>
ffffffff802011ec:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff802011f1:	eb 05                	jmp    ffffffff802011f8 <find_cmdslot+0x31>
ffffffff802011f3:	f6 c2 01             	test   $0x1,%dl
ffffffff802011f6:	74 25                	je     ffffffff8020121d <find_cmdslot+0x56>
            return i;

        // Next command slot status
        slots >>= 1;
ffffffff802011f8:	d1 ea                	shr    %edx
    int i;

    // Bit 12:08 - Number of command slots (1 to 32 maximum)
    uint8_t num_slots = (abar->cap >> 8) & 0x1F;

    for (i = 0; i < num_slots; i++) {
ffffffff802011fa:	ff c0                	inc    %eax
ffffffff802011fc:	39 c8                	cmp    %ecx,%eax
ffffffff802011fe:	75 f3                	jne    ffffffff802011f3 <find_cmdslot+0x2c>
            return i;

        // Next command slot status
        slots >>= 1;
    }
    kprintf("Cannot find free command slot\n");
ffffffff80201200:	48 8d 3d d1 18 00 00 	lea    0x18d1(%rip),%rdi        # ffffffff80202ad8 <_x86_64_asm_ltr+0xc43>
ffffffff80201207:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff8020120c:	e8 d4 f3 ff ff       	callq  ffffffff802005e5 <kprintf>

    return -1;
ffffffff80201211:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
ffffffff80201216:	eb 05                	jmp    ffffffff8020121d <find_cmdslot+0x56>
    int i;

    // Bit 12:08 - Number of command slots (1 to 32 maximum)
    uint8_t num_slots = (abar->cap >> 8) & 0x1F;

    for (i = 0; i < num_slots; i++) {
ffffffff80201218:	b8 00 00 00 00       	mov    $0x0,%eax
        slots >>= 1;
    }
    kprintf("Cannot find free command slot\n");

    return -1;
}
ffffffff8020121d:	48 83 c4 08          	add    $0x8,%rsp
ffffffff80201221:	c3                   	retq   

ffffffff80201222 <read>:

int read(hba_port_t *port, uint32_t startl, uint32_t starth, uint32_t count, uint8_t *buf) {
ffffffff80201222:	41 57                	push   %r15
ffffffff80201224:	41 56                	push   %r14
ffffffff80201226:	41 55                	push   %r13
ffffffff80201228:	41 54                	push   %r12
ffffffff8020122a:	55                   	push   %rbp
ffffffff8020122b:	53                   	push   %rbx
ffffffff8020122c:	48 83 ec 18          	sub    $0x18,%rsp
ffffffff80201230:	48 89 fb             	mov    %rdi,%rbx
ffffffff80201233:	41 89 f7             	mov    %esi,%r15d
ffffffff80201236:	89 54 24 0c          	mov    %edx,0xc(%rsp)
ffffffff8020123a:	41 89 cd             	mov    %ecx,%r13d
ffffffff8020123d:	4c 89 c5             	mov    %r8,%rbp
    port->is_rwc = (uint32_t)-1;   // Clear pending interrupt bits
ffffffff80201240:	c7 47 10 ff ff ff ff 	movl   $0xffffffff,0x10(%rdi)
    int i;
    int slot = find_cmdslot(port);
ffffffff80201247:	e8 7b ff ff ff       	callq  ffffffff802011c7 <find_cmdslot>
ffffffff8020124c:	89 c6                	mov    %eax,%esi
ffffffff8020124e:	89 44 24 08          	mov    %eax,0x8(%rsp)
    if (slot == -1)
        return 0;
ffffffff80201252:	b8 00 00 00 00       	mov    $0x0,%eax

int read(hba_port_t *port, uint32_t startl, uint32_t starth, uint32_t count, uint8_t *buf) {
    port->is_rwc = (uint32_t)-1;   // Clear pending interrupt bits
    int i;
    int slot = find_cmdslot(port);
    if (slot == -1)
ffffffff80201257:	83 fe ff             	cmp    $0xffffffff,%esi
ffffffff8020125a:	0f 84 8c 01 00 00    	je     ffffffff802013ec <read+0x1ca>
        return 0;

    hba_cmd_header_t *cmdheader = (hba_cmd_header_t*)port->clb;
ffffffff80201260:	48 8b 03             	mov    (%rbx),%rax
    cmdheader += slot;
ffffffff80201263:	4c 63 f6             	movslq %esi,%r14
ffffffff80201266:	49 c1 e6 05          	shl    $0x5,%r14
ffffffff8020126a:	49 01 c6             	add    %rax,%r14

    // Command FIS size
    cmdheader->cfl = sizeof(fis_reg_h2d_t) / sizeof(uint32_t);
ffffffff8020126d:	41 0f b6 06          	movzbl (%r14),%eax
ffffffff80201271:	83 e0 a0             	and    $0xffffffa0,%eax

    // Read from device
    cmdheader->w = 0;
ffffffff80201274:	83 c8 05             	or     $0x5,%eax
ffffffff80201277:	41 88 06             	mov    %al,(%r14)

    // PRDT entries count
    cmdheader->prdtl = (uint16_t)((count - 1) >> 3) + 1;
ffffffff8020127a:	41 8d 45 ff          	lea    -0x1(%r13),%eax
ffffffff8020127e:	c1 e8 03             	shr    $0x3,%eax
ffffffff80201281:	ff c0                	inc    %eax
ffffffff80201283:	66 41 89 46 02       	mov    %ax,0x2(%r14)

    hba_cmd_tbl_t *cmdtbl = (hba_cmd_tbl_t*)(cmdheader->ctba);
ffffffff80201288:	4d 8b 66 08          	mov    0x8(%r14),%r12
    memset(cmdtbl, 0, sizeof(hba_cmd_tbl_t) + (cmdheader->prdtl - 1) * sizeof(hba_prdt_entry_t));
ffffffff8020128c:	0f b7 d0             	movzwl %ax,%edx
ffffffff8020128f:	ff ca                	dec    %edx
ffffffff80201291:	48 63 d2             	movslq %edx,%rdx
ffffffff80201294:	48 83 c2 10          	add    $0x10,%rdx
ffffffff80201298:	48 c1 e2 04          	shl    $0x4,%rdx
ffffffff8020129c:	be 00 00 00 00       	mov    $0x0,%esi
ffffffff802012a1:	4c 89 e7             	mov    %r12,%rdi
ffffffff802012a4:	e8 ad 09 00 00       	callq  ffffffff80201c56 <memset>

    // 4K bytes (8 sectors) per PRDT
    for (i = 0; i < cmdheader->prdtl - 1; i++) {
ffffffff802012a9:	41 0f b7 46 02       	movzwl 0x2(%r14),%eax
ffffffff802012ae:	ff c8                	dec    %eax
ffffffff802012b0:	85 c0                	test   %eax,%eax
ffffffff802012b2:	7e 48                	jle    ffffffff802012fc <read+0xda>
ffffffff802012b4:	b9 00 00 00 00       	mov    $0x0,%ecx
        cmdtbl->prdt_entry[i].dba = (uint64_t)buf;
ffffffff802012b9:	48 63 c1             	movslq %ecx,%rax
ffffffff802012bc:	48 83 c0 08          	add    $0x8,%rax
ffffffff802012c0:	48 c1 e0 04          	shl    $0x4,%rax
ffffffff802012c4:	4c 01 e0             	add    %r12,%rax
ffffffff802012c7:	48 89 28             	mov    %rbp,(%rax)
        cmdtbl->prdt_entry[i].dbc = 4 * 1024; // 4K bytes
ffffffff802012ca:	8b 50 0c             	mov    0xc(%rax),%edx
ffffffff802012cd:	81 e2 00 00 c0 ff    	and    $0xffc00000,%edx
ffffffff802012d3:	80 ce 10             	or     $0x10,%dh
ffffffff802012d6:	89 50 0c             	mov    %edx,0xc(%rax)
        cmdtbl->prdt_entry[i].i = 1;
ffffffff802012d9:	c1 ea 18             	shr    $0x18,%edx
ffffffff802012dc:	83 ca 80             	or     $0xffffff80,%edx
ffffffff802012df:	88 50 0f             	mov    %dl,0xf(%rax)
        buf += 4 * 1024;  // 4K words
ffffffff802012e2:	48 81 c5 00 10 00 00 	add    $0x1000,%rbp
        count -= 8;    // 8 sectors
ffffffff802012e9:	41 83 ed 08          	sub    $0x8,%r13d

    hba_cmd_tbl_t *cmdtbl = (hba_cmd_tbl_t*)(cmdheader->ctba);
    memset(cmdtbl, 0, sizeof(hba_cmd_tbl_t) + (cmdheader->prdtl - 1) * sizeof(hba_prdt_entry_t));

    // 4K bytes (8 sectors) per PRDT
    for (i = 0; i < cmdheader->prdtl - 1; i++) {
ffffffff802012ed:	ff c1                	inc    %ecx
ffffffff802012ef:	41 0f b7 46 02       	movzwl 0x2(%r14),%eax
ffffffff802012f4:	ff c8                	dec    %eax
ffffffff802012f6:	39 c8                	cmp    %ecx,%eax
ffffffff802012f8:	7f bf                	jg     ffffffff802012b9 <read+0x97>
ffffffff802012fa:	eb 05                	jmp    ffffffff80201301 <read+0xdf>
ffffffff802012fc:	b9 00 00 00 00       	mov    $0x0,%ecx
        buf += 4 * 1024;  // 4K words
        count -= 8;    // 8 sectors
    }

    // Last entry
    cmdtbl->prdt_entry[i].dba = (uint64_t)buf;
ffffffff80201301:	48 63 c1             	movslq %ecx,%rax
ffffffff80201304:	48 83 c0 08          	add    $0x8,%rax
ffffffff80201308:	48 c1 e0 04          	shl    $0x4,%rax
ffffffff8020130c:	4c 01 e0             	add    %r12,%rax
ffffffff8020130f:	48 89 28             	mov    %rbp,(%rax)
    cmdtbl->prdt_entry[i].dbc = count << 9;   // 512 bytes per sector
ffffffff80201312:	44 89 ea             	mov    %r13d,%edx
ffffffff80201315:	c1 e2 09             	shl    $0x9,%edx
ffffffff80201318:	81 e2 ff ff 3f 00    	and    $0x3fffff,%edx
ffffffff8020131e:	8b 48 0c             	mov    0xc(%rax),%ecx
ffffffff80201321:	81 e1 00 00 c0 ff    	and    $0xffc00000,%ecx
ffffffff80201327:	09 ca                	or     %ecx,%edx
ffffffff80201329:	89 50 0c             	mov    %edx,0xc(%rax)
    cmdtbl->prdt_entry[i].i = 1;
ffffffff8020132c:	c1 ea 18             	shr    $0x18,%edx
ffffffff8020132f:	83 ca 80             	or     $0xffffff80,%edx
ffffffff80201332:	88 50 0f             	mov    %dl,0xf(%rax)

    // Setup command
    fis_reg_h2d_t *cmdfis = (fis_reg_h2d_t*)(&cmdtbl->cfis);

    cmdfis->fis_type = FIS_TYPE_REG_H2D;
ffffffff80201335:	41 c6 04 24 27       	movb   $0x27,(%r12)
    cmdfis->c = 1;  // Command
ffffffff8020133a:	41 80 4c 24 01 80    	orb    $0x80,0x1(%r12)
    cmdfis->command = ATA_CMD_READ_DMA_EX;
ffffffff80201340:	41 c6 44 24 02 25    	movb   $0x25,0x2(%r12)

    cmdfis->lba0 = (uint8_t)startl;
ffffffff80201346:	45 88 7c 24 04       	mov    %r15b,0x4(%r12)
    cmdfis->lba1 = (uint8_t)(startl >> 8);
ffffffff8020134b:	44 89 f8             	mov    %r15d,%eax
ffffffff8020134e:	c1 e8 08             	shr    $0x8,%eax
ffffffff80201351:	41 88 44 24 05       	mov    %al,0x5(%r12)
    cmdfis->lba2 = (uint8_t)(startl >> 16);
ffffffff80201356:	44 89 f8             	mov    %r15d,%eax
ffffffff80201359:	c1 e8 10             	shr    $0x10,%eax
ffffffff8020135c:	41 88 44 24 06       	mov    %al,0x6(%r12)
    cmdfis->device = 1 << 6;  // LBA mode
ffffffff80201361:	41 c6 44 24 07 40    	movb   $0x40,0x7(%r12)

    cmdfis->lba3 = (uint8_t)(startl >> 24);
ffffffff80201367:	41 c1 ef 18          	shr    $0x18,%r15d
ffffffff8020136b:	45 88 7c 24 08       	mov    %r15b,0x8(%r12)
    cmdfis->lba4 = (uint8_t)starth;
ffffffff80201370:	8b 44 24 0c          	mov    0xc(%rsp),%eax
ffffffff80201374:	41 88 44 24 09       	mov    %al,0x9(%r12)
    cmdfis->lba5 = (uint8_t)(starth >> 8);
ffffffff80201379:	c1 e8 08             	shr    $0x8,%eax
ffffffff8020137c:	41 88 44 24 0a       	mov    %al,0xa(%r12)

    cmdfis->count = count;
ffffffff80201381:	66 45 89 6c 24 0c    	mov    %r13w,0xc(%r12)

    // The below loop waits until the port is no longer busy before issuing a new command
    while ((port->tfd & (ATA_DEV_BUSY | ATA_DEV_DRQ)));
ffffffff80201387:	8b 43 20             	mov    0x20(%rbx),%eax
ffffffff8020138a:	a8 88                	test   $0x88,%al
ffffffff8020138c:	75 f9                	jne    ffffffff80201387 <read+0x165>
    port->ci = 1 << slot; // Issue command
ffffffff8020138e:	ba 01 00 00 00       	mov    $0x1,%edx
ffffffff80201393:	0f b6 4c 24 08       	movzbl 0x8(%rsp),%ecx
ffffffff80201398:	d3 e2                	shl    %cl,%edx
ffffffff8020139a:	89 53 38             	mov    %edx,0x38(%rbx)

    // Wait for completion
    while (1) {
        // In some longer duration reads, it may be helpful to spin on the DPS bit
        // in the PxIS port field as well (1 << 5)
        if (!(port->ci & (1 << slot))) {
ffffffff8020139d:	8b 43 38             	mov    0x38(%rbx),%eax
ffffffff802013a0:	85 c2                	test   %eax,%edx
ffffffff802013a2:	74 22                	je     ffffffff802013c6 <read+0x1a4>
            break;
        }

        // Task file error
        if (port->is_rwc & HBA_PxIS_TFES) {
ffffffff802013a4:	8b 43 10             	mov    0x10(%rbx),%eax
ffffffff802013a7:	a9 00 00 00 40       	test   $0x40000000,%eax
ffffffff802013ac:	74 ef                	je     ffffffff8020139d <read+0x17b>
            kprintf("Read disk error\n");
ffffffff802013ae:	48 8d 3d dd 0b 00 00 	lea    0xbdd(%rip),%rdi        # ffffffff80201f92 <_x86_64_asm_ltr+0xfd>
ffffffff802013b5:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff802013ba:	e8 26 f2 ff ff       	callq  ffffffff802005e5 <kprintf>
            return 0;
ffffffff802013bf:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff802013c4:	eb 26                	jmp    ffffffff802013ec <read+0x1ca>
        }
    }

    // Check again
    if (port->is_rwc & HBA_PxIS_TFES) {
ffffffff802013c6:	8b 53 10             	mov    0x10(%rbx),%edx
        kprintf("Read disk error\n");
        return 0;
    }

    return 1;
ffffffff802013c9:	b8 01 00 00 00       	mov    $0x1,%eax
            return 0;
        }
    }

    // Check again
    if (port->is_rwc & HBA_PxIS_TFES) {
ffffffff802013ce:	f7 c2 00 00 00 40    	test   $0x40000000,%edx
ffffffff802013d4:	74 16                	je     ffffffff802013ec <read+0x1ca>
        kprintf("Read disk error\n");
ffffffff802013d6:	48 8d 3d b5 0b 00 00 	lea    0xbb5(%rip),%rdi        # ffffffff80201f92 <_x86_64_asm_ltr+0xfd>
ffffffff802013dd:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff802013e2:	e8 fe f1 ff ff       	callq  ffffffff802005e5 <kprintf>
        return 0;
ffffffff802013e7:	b8 00 00 00 00       	mov    $0x0,%eax
    }

    return 1;
}
ffffffff802013ec:	48 83 c4 18          	add    $0x18,%rsp
ffffffff802013f0:	5b                   	pop    %rbx
ffffffff802013f1:	5d                   	pop    %rbp
ffffffff802013f2:	41 5c                	pop    %r12
ffffffff802013f4:	41 5d                	pop    %r13
ffffffff802013f6:	41 5e                	pop    %r14
ffffffff802013f8:	41 5f                	pop    %r15
ffffffff802013fa:	c3                   	retq   

ffffffff802013fb <write1>:


int write1(hba_port_t *port, uint32_t startl, uint32_t starth, uint32_t count, uint8_t *buf) {
ffffffff802013fb:	41 57                	push   %r15
ffffffff802013fd:	41 56                	push   %r14
ffffffff802013ff:	41 55                	push   %r13
ffffffff80201401:	41 54                	push   %r12
ffffffff80201403:	55                   	push   %rbp
ffffffff80201404:	53                   	push   %rbx
ffffffff80201405:	48 83 ec 18          	sub    $0x18,%rsp
ffffffff80201409:	48 89 fb             	mov    %rdi,%rbx
ffffffff8020140c:	41 89 f7             	mov    %esi,%r15d
ffffffff8020140f:	89 54 24 0c          	mov    %edx,0xc(%rsp)
ffffffff80201413:	41 89 cd             	mov    %ecx,%r13d
ffffffff80201416:	4c 89 c5             	mov    %r8,%rbp
    port->is_rwc = (uint32_t)-1;       // Clear pending interrupt bits
ffffffff80201419:	c7 47 10 ff ff ff ff 	movl   $0xffffffff,0x10(%rdi)
    int i;
    int slot = find_cmdslot(port);
ffffffff80201420:	e8 a2 fd ff ff       	callq  ffffffff802011c7 <find_cmdslot>
ffffffff80201425:	89 c6                	mov    %eax,%esi
ffffffff80201427:	89 44 24 08          	mov    %eax,0x8(%rsp)
    if (slot == -1)
        return 0;
ffffffff8020142b:	b8 00 00 00 00       	mov    $0x0,%eax

int write1(hba_port_t *port, uint32_t startl, uint32_t starth, uint32_t count, uint8_t *buf) {
    port->is_rwc = (uint32_t)-1;       // Clear pending interrupt bits
    int i;
    int slot = find_cmdslot(port);
    if (slot == -1)
ffffffff80201430:	83 fe ff             	cmp    $0xffffffff,%esi
ffffffff80201433:	0f 84 8c 01 00 00    	je     ffffffff802015c5 <write1+0x1ca>
        return 0;

    hba_cmd_header_t *cmdheader = (hba_cmd_header_t*)port->clb;
ffffffff80201439:	48 8b 03             	mov    (%rbx),%rax
    cmdheader += slot;
ffffffff8020143c:	4c 63 f6             	movslq %esi,%r14
ffffffff8020143f:	49 c1 e6 05          	shl    $0x5,%r14
ffffffff80201443:	49 01 c6             	add    %rax,%r14

    // Command FIS size
    cmdheader->cfl = sizeof(fis_reg_h2d_t) / sizeof(uint32_t);
ffffffff80201446:	41 0f b6 06          	movzbl (%r14),%eax
ffffffff8020144a:	83 e0 e0             	and    $0xffffffe0,%eax

    // Write to device
    cmdheader->w = 1;
ffffffff8020144d:	83 c8 45             	or     $0x45,%eax
ffffffff80201450:	41 88 06             	mov    %al,(%r14)

    // PRDT entries count
    cmdheader->prdtl = (uint16_t)((count - 1) >> 3) + 1;
ffffffff80201453:	41 8d 45 ff          	lea    -0x1(%r13),%eax
ffffffff80201457:	c1 e8 03             	shr    $0x3,%eax
ffffffff8020145a:	ff c0                	inc    %eax
ffffffff8020145c:	66 41 89 46 02       	mov    %ax,0x2(%r14)

    hba_cmd_tbl_t *cmdtbl = (hba_cmd_tbl_t*)(cmdheader->ctba);
ffffffff80201461:	4d 8b 66 08          	mov    0x8(%r14),%r12
    memset(cmdtbl, 0, sizeof(hba_cmd_tbl_t) + (cmdheader->prdtl - 1) * sizeof(hba_prdt_entry_t));
ffffffff80201465:	0f b7 d0             	movzwl %ax,%edx
ffffffff80201468:	ff ca                	dec    %edx
ffffffff8020146a:	48 63 d2             	movslq %edx,%rdx
ffffffff8020146d:	48 83 c2 10          	add    $0x10,%rdx
ffffffff80201471:	48 c1 e2 04          	shl    $0x4,%rdx
ffffffff80201475:	be 00 00 00 00       	mov    $0x0,%esi
ffffffff8020147a:	4c 89 e7             	mov    %r12,%rdi
ffffffff8020147d:	e8 d4 07 00 00       	callq  ffffffff80201c56 <memset>

    // 4K bytes (8 sectors) per PRDT
    for (i = 0; i < cmdheader->prdtl - 1; i++) {
ffffffff80201482:	41 0f b7 46 02       	movzwl 0x2(%r14),%eax
ffffffff80201487:	ff c8                	dec    %eax
ffffffff80201489:	85 c0                	test   %eax,%eax
ffffffff8020148b:	7e 48                	jle    ffffffff802014d5 <write1+0xda>
ffffffff8020148d:	b9 00 00 00 00       	mov    $0x0,%ecx
        cmdtbl->prdt_entry[i].dba = (uint64_t)buf;
ffffffff80201492:	48 63 c1             	movslq %ecx,%rax
ffffffff80201495:	48 83 c0 08          	add    $0x8,%rax
ffffffff80201499:	48 c1 e0 04          	shl    $0x4,%rax
ffffffff8020149d:	4c 01 e0             	add    %r12,%rax
ffffffff802014a0:	48 89 28             	mov    %rbp,(%rax)
        cmdtbl->prdt_entry[i].dbc = 4 * 1024; // 4K bytes
ffffffff802014a3:	8b 50 0c             	mov    0xc(%rax),%edx
ffffffff802014a6:	81 e2 00 00 c0 ff    	and    $0xffc00000,%edx
ffffffff802014ac:	80 ce 10             	or     $0x10,%dh
ffffffff802014af:	89 50 0c             	mov    %edx,0xc(%rax)
        cmdtbl->prdt_entry[i].i = 1;
ffffffff802014b2:	c1 ea 18             	shr    $0x18,%edx
ffffffff802014b5:	83 ca 80             	or     $0xffffff80,%edx
ffffffff802014b8:	88 50 0f             	mov    %dl,0xf(%rax)
        buf += 4 * 1024;  // 4K words
ffffffff802014bb:	48 81 c5 00 10 00 00 	add    $0x1000,%rbp
        count -= 8;    // 8 sectors
ffffffff802014c2:	41 83 ed 08          	sub    $0x8,%r13d

    hba_cmd_tbl_t *cmdtbl = (hba_cmd_tbl_t*)(cmdheader->ctba);
    memset(cmdtbl, 0, sizeof(hba_cmd_tbl_t) + (cmdheader->prdtl - 1) * sizeof(hba_prdt_entry_t));

    // 4K bytes (8 sectors) per PRDT
    for (i = 0; i < cmdheader->prdtl - 1; i++) {
ffffffff802014c6:	ff c1                	inc    %ecx
ffffffff802014c8:	41 0f b7 46 02       	movzwl 0x2(%r14),%eax
ffffffff802014cd:	ff c8                	dec    %eax
ffffffff802014cf:	39 c8                	cmp    %ecx,%eax
ffffffff802014d1:	7f bf                	jg     ffffffff80201492 <write1+0x97>
ffffffff802014d3:	eb 05                	jmp    ffffffff802014da <write1+0xdf>
ffffffff802014d5:	b9 00 00 00 00       	mov    $0x0,%ecx
        buf += 4 * 1024;  // 4K words
        count -= 8;    // 8 sectors
    }

    // Last entry
    cmdtbl->prdt_entry[i].dba = (uint64_t)buf;
ffffffff802014da:	48 63 c1             	movslq %ecx,%rax
ffffffff802014dd:	48 83 c0 08          	add    $0x8,%rax
ffffffff802014e1:	48 c1 e0 04          	shl    $0x4,%rax
ffffffff802014e5:	4c 01 e0             	add    %r12,%rax
ffffffff802014e8:	48 89 28             	mov    %rbp,(%rax)
    cmdtbl->prdt_entry[i].dbc = count << 9;   // 512 bytes per sector
ffffffff802014eb:	44 89 ea             	mov    %r13d,%edx
ffffffff802014ee:	c1 e2 09             	shl    $0x9,%edx
ffffffff802014f1:	81 e2 ff ff 3f 00    	and    $0x3fffff,%edx
ffffffff802014f7:	8b 48 0c             	mov    0xc(%rax),%ecx
ffffffff802014fa:	81 e1 00 00 c0 ff    	and    $0xffc00000,%ecx
ffffffff80201500:	09 ca                	or     %ecx,%edx
ffffffff80201502:	89 50 0c             	mov    %edx,0xc(%rax)
    cmdtbl->prdt_entry[i].i = 1;
ffffffff80201505:	c1 ea 18             	shr    $0x18,%edx
ffffffff80201508:	83 ca 80             	or     $0xffffff80,%edx
ffffffff8020150b:	88 50 0f             	mov    %dl,0xf(%rax)

    // Setup command
    fis_reg_h2d_t *cmdfis = (fis_reg_h2d_t*)(&cmdtbl->cfis);

    cmdfis->fis_type = FIS_TYPE_REG_H2D;
ffffffff8020150e:	41 c6 04 24 27       	movb   $0x27,(%r12)
    cmdfis->c = 1;  // Command
ffffffff80201513:	41 80 4c 24 01 80    	orb    $0x80,0x1(%r12)
    cmdfis->command = ATA_CMD_WRITE_DMA_EX;
ffffffff80201519:	41 c6 44 24 02 35    	movb   $0x35,0x2(%r12)

    cmdfis->lba0 = (uint8_t)startl;
ffffffff8020151f:	45 88 7c 24 04       	mov    %r15b,0x4(%r12)
    cmdfis->lba1 = (uint8_t)(startl >> 8);
ffffffff80201524:	44 89 f8             	mov    %r15d,%eax
ffffffff80201527:	c1 e8 08             	shr    $0x8,%eax
ffffffff8020152a:	41 88 44 24 05       	mov    %al,0x5(%r12)
    cmdfis->lba2 = (uint8_t)(startl >> 16);
ffffffff8020152f:	44 89 f8             	mov    %r15d,%eax
ffffffff80201532:	c1 e8 10             	shr    $0x10,%eax
ffffffff80201535:	41 88 44 24 06       	mov    %al,0x6(%r12)
    cmdfis->device = 1 << 6;  // LBA mode
ffffffff8020153a:	41 c6 44 24 07 40    	movb   $0x40,0x7(%r12)

    cmdfis->lba3 = (uint8_t)(startl >> 24);
ffffffff80201540:	41 c1 ef 18          	shr    $0x18,%r15d
ffffffff80201544:	45 88 7c 24 08       	mov    %r15b,0x8(%r12)
    cmdfis->lba4 = (uint8_t)starth;
ffffffff80201549:	8b 44 24 0c          	mov    0xc(%rsp),%eax
ffffffff8020154d:	41 88 44 24 09       	mov    %al,0x9(%r12)
    cmdfis->lba5 = (uint8_t)(starth >> 8);
ffffffff80201552:	c1 e8 08             	shr    $0x8,%eax
ffffffff80201555:	41 88 44 24 0a       	mov    %al,0xa(%r12)

    cmdfis->count = count;
ffffffff8020155a:	66 45 89 6c 24 0c    	mov    %r13w,0xc(%r12)

    // The below loop waits until the port is no longer busy before issuing a new command
    while ((port->tfd & (ATA_DEV_BUSY | ATA_DEV_DRQ)));
ffffffff80201560:	8b 43 20             	mov    0x20(%rbx),%eax
ffffffff80201563:	a8 88                	test   $0x88,%al
ffffffff80201565:	75 f9                	jne    ffffffff80201560 <write1+0x165>

    port->ci = 1 << slot; // Issue command
ffffffff80201567:	ba 01 00 00 00       	mov    $0x1,%edx
ffffffff8020156c:	0f b6 4c 24 08       	movzbl 0x8(%rsp),%ecx
ffffffff80201571:	d3 e2                	shl    %cl,%edx
ffffffff80201573:	89 53 38             	mov    %edx,0x38(%rbx)
    // Wait for completion
    while (1)
    {
        // In some longer duration reads, it may be helpful to spin on the DPS bit
        // in the PxIS port field as well (1 << 5)
        if (!(port->ci & (1 << slot))) {
ffffffff80201576:	8b 43 38             	mov    0x38(%rbx),%eax
ffffffff80201579:	85 c2                	test   %eax,%edx
ffffffff8020157b:	74 22                	je     ffffffff8020159f <write1+0x1a4>
            break;
        }

        // Task file error
        if (port->is_rwc & HBA_PxIS_TFES) {
ffffffff8020157d:	8b 43 10             	mov    0x10(%rbx),%eax
ffffffff80201580:	a9 00 00 00 40       	test   $0x40000000,%eax
ffffffff80201585:	74 ef                	je     ffffffff80201576 <write1+0x17b>
            kprintf("Write disk error\n");
ffffffff80201587:	48 8d 3d 15 0a 00 00 	lea    0xa15(%rip),%rdi        # ffffffff80201fa3 <_x86_64_asm_ltr+0x10e>
ffffffff8020158e:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80201593:	e8 4d f0 ff ff       	callq  ffffffff802005e5 <kprintf>
            return 0;
ffffffff80201598:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff8020159d:	eb 26                	jmp    ffffffff802015c5 <write1+0x1ca>
        }
    }

    // Check again
    if (port->is_rwc & HBA_PxIS_TFES) {
ffffffff8020159f:	8b 53 10             	mov    0x10(%rbx),%edx
        kprintf("Write disk error\n");
        return 0;
    }

    return 1;
ffffffff802015a2:	b8 01 00 00 00       	mov    $0x1,%eax
            return 0;
        }
    }

    // Check again
    if (port->is_rwc & HBA_PxIS_TFES) {
ffffffff802015a7:	f7 c2 00 00 00 40    	test   $0x40000000,%edx
ffffffff802015ad:	74 16                	je     ffffffff802015c5 <write1+0x1ca>
        kprintf("Write disk error\n");
ffffffff802015af:	48 8d 3d ed 09 00 00 	lea    0x9ed(%rip),%rdi        # ffffffff80201fa3 <_x86_64_asm_ltr+0x10e>
ffffffff802015b6:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff802015bb:	e8 25 f0 ff ff       	callq  ffffffff802005e5 <kprintf>
        return 0;
ffffffff802015c0:	b8 00 00 00 00       	mov    $0x0,%eax
    }

    return 1;
}
ffffffff802015c5:	48 83 c4 18          	add    $0x18,%rsp
ffffffff802015c9:	5b                   	pop    %rbx
ffffffff802015ca:	5d                   	pop    %rbp
ffffffff802015cb:	41 5c                	pop    %r12
ffffffff802015cd:	41 5d                	pop    %r13
ffffffff802015cf:	41 5e                	pop    %r14
ffffffff802015d1:	41 5f                	pop    %r15
ffffffff802015d3:	c3                   	retq   

ffffffff802015d4 <port_reset>:

// Serial ATA AHCI 1.3.1 Specification (Section 10.4.2)
void port_reset(hba_port_t *port) {
ffffffff802015d4:	53                   	push   %rbx
ffffffff802015d5:	48 89 fb             	mov    %rdi,%rbx
    uint32_t flag;

    // Invoke a COMRESET on the interface and start a re-establishment of Phy layer communications
    // Transitions to both Partial and Slumber states disabled
    port->sctl = 0x301;
ffffffff802015d8:	c7 47 2c 01 03 00 00 	movl   $0x301,0x2c(%rdi)
    delay();
ffffffff802015df:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff802015e4:	e8 d3 fb ff ff       	callq  ffffffff802011bc <delay>

    // Clearing PxSCTL.DET to 0h; this ensures that at least one COMRESET signal is sent over the interface
    port->sctl = 0x300;
ffffffff802015e9:	c7 43 2c 00 03 00 00 	movl   $0x300,0x2c(%rbx)
    delay();
ffffffff802015f0:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff802015f5:	e8 c2 fb ff ff       	callq  ffffffff802011bc <delay>

    // Set Spin-Up Device (SUD)
    port->cmd |= 0x00000002;
ffffffff802015fa:	8b 43 18             	mov    0x18(%rbx),%eax
ffffffff802015fd:	83 c8 02             	or     $0x2,%eax
ffffffff80201600:	89 43 18             	mov    %eax,0x18(%rbx)
    delay();
ffffffff80201603:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80201608:	e8 af fb ff ff       	callq  ffffffff802011bc <delay>

    // Set Power On Device (POD)
    port->cmd |= 0x00000004;
ffffffff8020160d:	8b 43 18             	mov    0x18(%rbx),%eax
ffffffff80201610:	83 c8 04             	or     $0x4,%eax
ffffffff80201613:	89 43 18             	mov    %eax,0x18(%rbx)
    delay();
ffffffff80201616:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff8020161b:	e8 9c fb ff ff       	callq  ffffffff802011bc <delay>

    // Set Interface Communication Control (ICC)
    flag = port->cmd;
ffffffff80201620:	8b 43 18             	mov    0x18(%rbx),%eax
    flag &= 0x0FFFFFFF;
ffffffff80201623:	25 ff ff ff 0f       	and    $0xfffffff,%eax
    flag |= 0x10000000;
ffffffff80201628:	0d 00 00 00 10       	or     $0x10000000,%eax
    port->cmd = flag;
ffffffff8020162d:	89 43 18             	mov    %eax,0x18(%rbx)
    delay();
ffffffff80201630:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80201635:	e8 82 fb ff ff       	callq  ffffffff802011bc <delay>

    // Write all 1s to the PxSERR register to clear any bits that were set as part of the port reset
    port->serr_rwc = 0xFFFFFFFF;
ffffffff8020163a:	c7 43 30 ff ff ff ff 	movl   $0xffffffff,0x30(%rbx)
    delay();
ffffffff80201641:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80201646:	e8 71 fb ff ff       	callq  ffffffff802011bc <delay>

    // Write all 1s to the PxIS register to clear any bits that were set as part of the port reset
    port->is_rwc = 0xFFFFFFFF;
ffffffff8020164b:	c7 43 10 ff ff ff ff 	movl   $0xffffffff,0x10(%rbx)
    delay();
ffffffff80201652:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80201657:	e8 60 fb ff ff       	callq  ffffffff802011bc <delay>

    // Wait for communication to be re-established
    while ((port->ssts & 0x0F) != 3);
ffffffff8020165c:	8b 43 28             	mov    0x28(%rbx),%eax
ffffffff8020165f:	83 e0 0f             	and    $0xf,%eax
ffffffff80201662:	83 f8 03             	cmp    $0x3,%eax
ffffffff80201665:	75 f5                	jne    ffffffff8020165c <port_reset+0x88>
    delay();
ffffffff80201667:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff8020166c:	e8 4b fb ff ff       	callq  ffffffff802011bc <delay>
}
ffffffff80201671:	5b                   	pop    %rbx
ffffffff80201672:	c3                   	retq   

ffffffff80201673 <start_cmd>:

// Start command engine (Section 3.3.7 Serial ATA AHCI 1.3.1 Specification)
void start_cmd(hba_port_t *port) {
ffffffff80201673:	53                   	push   %rbx
ffffffff80201674:	48 89 fb             	mov    %rdi,%rbx
    port_reset(port);
ffffffff80201677:	e8 58 ff ff ff       	callq  ffffffff802015d4 <port_reset>

    // Wait until CR (bit15) is cleared
    while (port->cmd & HBA_PxCMD_CR);
ffffffff8020167c:	8b 43 18             	mov    0x18(%rbx),%eax
ffffffff8020167f:	f6 c4 80             	test   $0x80,%ah
ffffffff80201682:	75 f8                	jne    ffffffff8020167c <start_cmd+0x9>

    // Set FRE (bit4)
    port->cmd |= HBA_PxCMD_FRE;
ffffffff80201684:	8b 43 18             	mov    0x18(%rbx),%eax
ffffffff80201687:	83 c8 10             	or     $0x10,%eax
ffffffff8020168a:	89 43 18             	mov    %eax,0x18(%rbx)
    delay();
ffffffff8020168d:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80201692:	e8 25 fb ff ff       	callq  ffffffff802011bc <delay>

    // Set ST (bit0)
    port->cmd |= HBA_PxCMD_ST;
ffffffff80201697:	8b 43 18             	mov    0x18(%rbx),%eax
ffffffff8020169a:	83 c8 01             	or     $0x1,%eax
ffffffff8020169d:	89 43 18             	mov    %eax,0x18(%rbx)
    delay();
ffffffff802016a0:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff802016a5:	e8 12 fb ff ff       	callq  ffffffff802011bc <delay>
}
ffffffff802016aa:	5b                   	pop    %rbx
ffffffff802016ab:	c3                   	retq   

ffffffff802016ac <stop_cmd>:

// Stop command engine
void stop_cmd(hba_port_t *port) {
ffffffff802016ac:	53                   	push   %rbx
ffffffff802016ad:	48 89 fb             	mov    %rdi,%rbx
    // Clear ST (bit0)
    port->cmd &= ~HBA_PxCMD_ST;
ffffffff802016b0:	8b 47 18             	mov    0x18(%rdi),%eax
ffffffff802016b3:	83 e0 fe             	and    $0xfffffffe,%eax
ffffffff802016b6:	89 47 18             	mov    %eax,0x18(%rdi)
    delay();
ffffffff802016b9:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff802016be:	e8 f9 fa ff ff       	callq  ffffffff802011bc <delay>
    while (port->cmd & HBA_PxCMD_CR);
ffffffff802016c3:	8b 43 18             	mov    0x18(%rbx),%eax
ffffffff802016c6:	f6 c4 80             	test   $0x80,%ah
ffffffff802016c9:	75 f8                	jne    ffffffff802016c3 <stop_cmd+0x17>

    // Clear FRE (bit4)
    port->cmd &= ~HBA_PxCMD_FRE;
ffffffff802016cb:	8b 43 18             	mov    0x18(%rbx),%eax
ffffffff802016ce:	83 e0 ef             	and    $0xffffffef,%eax
ffffffff802016d1:	89 43 18             	mov    %eax,0x18(%rbx)
    delay();
ffffffff802016d4:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff802016d9:	e8 de fa ff ff       	callq  ffffffff802011bc <delay>
    while (port->cmd & HBA_PxCMD_FR);
ffffffff802016de:	8b 43 18             	mov    0x18(%rbx),%eax
ffffffff802016e1:	f6 c4 40             	test   $0x40,%ah
ffffffff802016e4:	75 f8                	jne    ffffffff802016de <stop_cmd+0x32>
}
ffffffff802016e6:	5b                   	pop    %rbx
ffffffff802016e7:	c3                   	retq   

ffffffff802016e8 <port_rebase>:

void port_rebase(hba_port_t *port, int portno) {
ffffffff802016e8:	41 55                	push   %r13
ffffffff802016ea:	41 54                	push   %r12
ffffffff802016ec:	55                   	push   %rbp
ffffffff802016ed:	53                   	push   %rbx
ffffffff802016ee:	48 83 ec 08          	sub    $0x8,%rsp
ffffffff802016f2:	49 89 fd             	mov    %rdi,%r13
ffffffff802016f5:	41 89 f4             	mov    %esi,%r12d
    int i;

    stop_cmd(port); // Stop command engine
ffffffff802016f8:	e8 af ff ff ff       	callq  ffffffff802016ac <stop_cmd>

    // Command list offset: 1K*portno
    // Command list entry size = 32
    // Command list entry maxim count = 32
    // Command list maxim size = 32*32 = 1K per port
    port->clb = AHCI_BASE + (portno << 10);
ffffffff802016fd:	44 89 e0             	mov    %r12d,%eax
ffffffff80201700:	c1 e0 0a             	shl    $0xa,%eax
ffffffff80201703:	05 00 00 80 00       	add    $0x800000,%eax
ffffffff80201708:	48 98                	cltq   
ffffffff8020170a:	49 89 45 00          	mov    %rax,0x0(%r13)
    memset((void*)(port->clb), 0, 1024);
ffffffff8020170e:	49 8b 7d 00          	mov    0x0(%r13),%rdi
ffffffff80201712:	ba 00 04 00 00       	mov    $0x400,%edx
ffffffff80201717:	be 00 00 00 00       	mov    $0x0,%esi
ffffffff8020171c:	e8 35 05 00 00       	callq  ffffffff80201c56 <memset>

    // FIS offset: 32K+256*portno
    // FIS entry size = 256 bytes per port
    port->fb = AHCI_BASE + (32 << 10) + (portno << 8);
ffffffff80201721:	44 89 e0             	mov    %r12d,%eax
ffffffff80201724:	c1 e0 08             	shl    $0x8,%eax
ffffffff80201727:	05 00 80 80 00       	add    $0x808000,%eax
ffffffff8020172c:	48 98                	cltq   
ffffffff8020172e:	49 89 45 08          	mov    %rax,0x8(%r13)
    memset((void*)(port->fb), 0, 256);
ffffffff80201732:	49 8b 7d 08          	mov    0x8(%r13),%rdi
ffffffff80201736:	ba 00 01 00 00       	mov    $0x100,%edx
ffffffff8020173b:	be 00 00 00 00       	mov    $0x0,%esi
ffffffff80201740:	e8 11 05 00 00       	callq  ffffffff80201c56 <memset>

    // Command table offset: 40K + 8K*portno
    // Command table size = 256*32 = 8K per port
    hba_cmd_header_t *cmdheader = (hba_cmd_header_t*)(port->clb);
ffffffff80201745:	49 8b 5d 00          	mov    0x0(%r13),%rbx
    	// 8 prdt entries per command table
    	// 256 bytes per command table, 64+16+48+16*8
        cmdheader[i].prdtl = 8;

        // Command table offset: 40K + 8K*portno + cmdheader_index*256
        cmdheader[i].ctba = AHCI_BASE + (40 << 10) + (portno << 13) + (i << 8);
ffffffff80201749:	41 c1 e4 0d          	shl    $0xd,%r12d
ffffffff8020174d:	41 81 c4 00 a0 80 00 	add    $0x80a000,%r12d
ffffffff80201754:	48 83 c3 02          	add    $0x2,%rbx
    memset((void*)(port->fb), 0, 256);

    // Command table offset: 40K + 8K*portno
    // Command table size = 256*32 = 8K per port
    hba_cmd_header_t *cmdheader = (hba_cmd_header_t*)(port->clb);
    for (i = 0; i < 32; i++) {
ffffffff80201758:	bd 00 00 00 00       	mov    $0x0,%ebp

    	// 8 prdt entries per command table
    	// 256 bytes per command table, 64+16+48+16*8
        cmdheader[i].prdtl = 8;
ffffffff8020175d:	66 c7 03 08 00       	movw   $0x8,(%rbx)

        // Command table offset: 40K + 8K*portno + cmdheader_index*256
        cmdheader[i].ctba = AHCI_BASE + (40 << 10) + (portno << 13) + (i << 8);
ffffffff80201762:	89 ef                	mov    %ebp,%edi
ffffffff80201764:	c1 e7 08             	shl    $0x8,%edi
ffffffff80201767:	44 01 e7             	add    %r12d,%edi
ffffffff8020176a:	48 63 ff             	movslq %edi,%rdi
ffffffff8020176d:	48 89 7b 06          	mov    %rdi,0x6(%rbx)
        memset((void*)cmdheader[i].ctba, 0, 256);
ffffffff80201771:	ba 00 01 00 00       	mov    $0x100,%edx
ffffffff80201776:	be 00 00 00 00       	mov    $0x0,%esi
ffffffff8020177b:	e8 d6 04 00 00       	callq  ffffffff80201c56 <memset>
    memset((void*)(port->fb), 0, 256);

    // Command table offset: 40K + 8K*portno
    // Command table size = 256*32 = 8K per port
    hba_cmd_header_t *cmdheader = (hba_cmd_header_t*)(port->clb);
    for (i = 0; i < 32; i++) {
ffffffff80201780:	ff c5                	inc    %ebp
ffffffff80201782:	48 83 c3 20          	add    $0x20,%rbx
ffffffff80201786:	83 fd 20             	cmp    $0x20,%ebp
ffffffff80201789:	75 d2                	jne    ffffffff8020175d <port_rebase+0x75>
        cmdheader[i].ctba = AHCI_BASE + (40 << 10) + (portno << 13) + (i << 8);
        memset((void*)cmdheader[i].ctba, 0, 256);
    }

    // Start command engine
    start_cmd(port);
ffffffff8020178b:	4c 89 ef             	mov    %r13,%rdi
ffffffff8020178e:	e8 e0 fe ff ff       	callq  ffffffff80201673 <start_cmd>
}
ffffffff80201793:	48 83 c4 08          	add    $0x8,%rsp
ffffffff80201797:	5b                   	pop    %rbx
ffffffff80201798:	5d                   	pop    %rbp
ffffffff80201799:	41 5c                	pop    %r12
ffffffff8020179b:	41 5d                	pop    %r13
ffffffff8020179d:	c3                   	retq   

ffffffff8020179e <check_type>:

// Check device type
int check_type(hba_port_t *port) {
    switch (port->sig) {
ffffffff8020179e:	8b 57 24             	mov    0x24(%rdi),%edx
        case SATA_SIG_ATAPI:
            return AHCI_DEV_SATAPI;
        case SATA_SIG_SEMB:
            return AHCI_DEV_SEMB;
        case SATA_SIG_PM:
            return AHCI_DEV_PM;
ffffffff802017a1:	b8 01 01 69 96       	mov    $0x96690101,%eax
    start_cmd(port);
}

// Check device type
int check_type(hba_port_t *port) {
    switch (port->sig) {
ffffffff802017a6:	39 c2                	cmp    %eax,%edx
ffffffff802017a8:	74 2a                	je     ffffffff802017d4 <check_type+0x36>
ffffffff802017aa:	39 c2                	cmp    %eax,%edx
ffffffff802017ac:	77 0f                	ja     ffffffff802017bd <check_type+0x1f>
        case SATA_SIG_SEMB:
            return AHCI_DEV_SEMB;
        case SATA_SIG_PM:
            return AHCI_DEV_PM;
        case SATA_SIG_ATA:
            return AHCI_DEV_SATA;
ffffffff802017ae:	b8 01 01 00 00       	mov    $0x101,%eax
    start_cmd(port);
}

// Check device type
int check_type(hba_port_t *port) {
    switch (port->sig) {
ffffffff802017b3:	81 fa 01 01 00 00    	cmp    $0x101,%edx
ffffffff802017b9:	74 19                	je     ffffffff802017d4 <check_type+0x36>
ffffffff802017bb:	eb 12                	jmp    ffffffff802017cf <check_type+0x31>
        case SATA_SIG_ATAPI:
            return AHCI_DEV_SATAPI;
        case SATA_SIG_SEMB:
            return AHCI_DEV_SEMB;
ffffffff802017bd:	b8 01 01 3c c3       	mov    $0xc33c0101,%eax
    start_cmd(port);
}

// Check device type
int check_type(hba_port_t *port) {
    switch (port->sig) {
ffffffff802017c2:	39 c2                	cmp    %eax,%edx
ffffffff802017c4:	74 0e                	je     ffffffff802017d4 <check_type+0x36>
        case SATA_SIG_ATAPI:
            return AHCI_DEV_SATAPI;
ffffffff802017c6:	b8 01 01 14 eb       	mov    $0xeb140101,%eax
    start_cmd(port);
}

// Check device type
int check_type(hba_port_t *port) {
    switch (port->sig) {
ffffffff802017cb:	39 c2                	cmp    %eax,%edx
ffffffff802017cd:	74 05                	je     ffffffff802017d4 <check_type+0x36>
        case SATA_SIG_PM:
            return AHCI_DEV_PM;
        case SATA_SIG_ATA:
            return AHCI_DEV_SATA;
        default:
            return -1;
ffffffff802017cf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    }
}
ffffffff802017d4:	f3 c3                	repz retq 

ffffffff802017d6 <verify_read_write>:

// Verify read and write to disks
void verify_read_write(uint8_t port) {
ffffffff802017d6:	41 57                	push   %r15
ffffffff802017d8:	41 56                	push   %r14
ffffffff802017da:	41 55                	push   %r13
ffffffff802017dc:	41 54                	push   %r12
ffffffff802017de:	55                   	push   %rbp
ffffffff802017df:	53                   	push   %rbx
ffffffff802017e0:	48 83 ec 08          	sub    $0x8,%rsp
ffffffff802017e4:	41 89 ff             	mov    %edi,%r15d
    uint32_t i, j;
    int flag = 0;
    uint8_t *write_buffer = (uint8_t *)0x400000, *read_buffer = (uint8_t *)0x500000;

    kprintf("Writing to disk ...\n");
ffffffff802017e7:	48 8d 3d c7 07 00 00 	lea    0x7c7(%rip),%rdi        # ffffffff80201fb5 <_x86_64_asm_ltr+0x120>
ffffffff802017ee:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff802017f3:	e8 ed ed ff ff       	callq  ffffffff802005e5 <kprintf>

    // Write 0 to the first 4KB Block
    // 512 bytes * 8 blocks = 4096 KB
    memset(write_buffer, 0, BLOCK_SIZE);
ffffffff802017f8:	ba 00 10 00 00       	mov    $0x1000,%edx
ffffffff802017fd:	be 00 00 00 00       	mov    $0x0,%esi
ffffffff80201802:	bf 00 00 40 00       	mov    $0x400000,%edi
ffffffff80201807:	e8 4a 04 00 00       	callq  ffffffff80201c56 <memset>
    write1(&abar->ports[port], 0, 0, 8, write_buffer);
ffffffff8020180c:	45 0f b6 ff          	movzbl %r15b,%r15d
ffffffff80201810:	49 63 ff             	movslq %r15d,%rdi
ffffffff80201813:	48 83 c7 02          	add    $0x2,%rdi
ffffffff80201817:	48 c1 e7 07          	shl    $0x7,%rdi
ffffffff8020181b:	48 8d 05 3e 4b 00 00 	lea    0x4b3e(%rip),%rax        # ffffffff80206360 <abar>
ffffffff80201822:	48 03 38             	add    (%rax),%rdi
ffffffff80201825:	41 b8 00 00 40 00    	mov    $0x400000,%r8d
ffffffff8020182b:	b9 08 00 00 00       	mov    $0x8,%ecx
ffffffff80201830:	ba 00 00 00 00       	mov    $0x0,%edx
ffffffff80201835:	be 00 00 00 00       	mov    $0x0,%esi
ffffffff8020183a:	e8 bc fb ff ff       	callq  ffffffff802013fb <write1>

    for (i = 0; i < NUM_BLOCKS; i++) {
ffffffff8020183f:	bb 00 00 00 00       	mov    $0x0,%ebx
        memset(write_buffer, i, BLOCK_SIZE);
        write1(&abar->ports[port], i * 8, 0, 8, write_buffer);
ffffffff80201844:	49 63 ef             	movslq %r15d,%rbp
ffffffff80201847:	48 83 c5 02          	add    $0x2,%rbp
ffffffff8020184b:	48 c1 e5 07          	shl    $0x7,%rbp
    // 512 bytes * 8 blocks = 4096 KB
    memset(write_buffer, 0, BLOCK_SIZE);
    write1(&abar->ports[port], 0, 0, 8, write_buffer);

    for (i = 0; i < NUM_BLOCKS; i++) {
        memset(write_buffer, i, BLOCK_SIZE);
ffffffff8020184f:	ba 00 10 00 00       	mov    $0x1000,%edx
ffffffff80201854:	89 de                	mov    %ebx,%esi
ffffffff80201856:	bf 00 00 40 00       	mov    $0x400000,%edi
ffffffff8020185b:	e8 f6 03 00 00       	callq  ffffffff80201c56 <memset>
        write1(&abar->ports[port], i * 8, 0, 8, write_buffer);
ffffffff80201860:	8d 34 dd 00 00 00 00 	lea    0x0(,%rbx,8),%esi
ffffffff80201867:	48 8d 05 f2 4a 00 00 	lea    0x4af2(%rip),%rax        # ffffffff80206360 <abar>
ffffffff8020186e:	48 89 ef             	mov    %rbp,%rdi
ffffffff80201871:	48 03 38             	add    (%rax),%rdi
ffffffff80201874:	41 b8 00 00 40 00    	mov    $0x400000,%r8d
ffffffff8020187a:	b9 08 00 00 00       	mov    $0x8,%ecx
ffffffff8020187f:	ba 00 00 00 00       	mov    $0x0,%edx
ffffffff80201884:	e8 72 fb ff ff       	callq  ffffffff802013fb <write1>
    // Write 0 to the first 4KB Block
    // 512 bytes * 8 blocks = 4096 KB
    memset(write_buffer, 0, BLOCK_SIZE);
    write1(&abar->ports[port], 0, 0, 8, write_buffer);

    for (i = 0; i < NUM_BLOCKS; i++) {
ffffffff80201889:	ff c3                	inc    %ebx
ffffffff8020188b:	83 fb 64             	cmp    $0x64,%ebx
ffffffff8020188e:	75 bf                	jne    ffffffff8020184f <verify_read_write+0x79>
        memset(write_buffer, i, BLOCK_SIZE);
        write1(&abar->ports[port], i * 8, 0, 8, write_buffer);
    }

    kprintf("Reading from disk ...\n");
ffffffff80201890:	48 8d 3d 33 07 00 00 	lea    0x733(%rip),%rdi        # ffffffff80201fca <_x86_64_asm_ltr+0x135>
ffffffff80201897:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff8020189c:	e8 44 ed ff ff       	callq  ffffffff802005e5 <kprintf>

    for (i = 0; i < NUM_BLOCKS; i++) {
ffffffff802018a1:	41 bc 00 00 00 00    	mov    $0x0,%r12d
        read(&abar->ports[port], i * 8, 0, 8, read_buffer);
ffffffff802018a7:	4c 8d 35 b2 4a 00 00 	lea    0x4ab2(%rip),%r14        # ffffffff80206360 <abar>
ffffffff802018ae:	4d 63 ef             	movslq %r15d,%r13
ffffffff802018b1:	49 83 c5 02          	add    $0x2,%r13
ffffffff802018b5:	49 c1 e5 07          	shl    $0x7,%r13
ffffffff802018b9:	42 8d 34 e5 00 00 00 	lea    0x0(,%r12,8),%esi
ffffffff802018c0:	00 
ffffffff802018c1:	4c 89 ef             	mov    %r13,%rdi
ffffffff802018c4:	49 03 3e             	add    (%r14),%rdi
ffffffff802018c7:	41 b8 00 00 50 00    	mov    $0x500000,%r8d
ffffffff802018cd:	b9 08 00 00 00       	mov    $0x8,%ecx
ffffffff802018d2:	ba 00 00 00 00       	mov    $0x0,%edx
ffffffff802018d7:	e8 46 f9 ff ff       	callq  ffffffff80201222 <read>
ffffffff802018dc:	bd 01 00 00 00       	mov    $0x1,%ebp
ffffffff802018e1:	bb 00 00 00 00       	mov    $0x0,%ebx
ffffffff802018e6:	eb 05                	jmp    ffffffff802018ed <verify_read_write+0x117>
ffffffff802018e8:	48 ff c3             	inc    %rbx
ffffffff802018eb:	ff c5                	inc    %ebp
        for (j = 0; j < BLOCK_SIZE; j++) {
            if (j == 0) {
ffffffff802018ed:	85 db                	test   %ebx,%ebx
ffffffff802018ef:	75 27                	jne    ffffffff80201918 <verify_read_write+0x142>
                kprintf("%d ", read_buffer[j]);
ffffffff802018f1:	0f b6 34 25 00 00 50 	movzbl 0x500000,%esi
ffffffff802018f8:	00 
ffffffff802018f9:	48 8d 3d e1 06 00 00 	lea    0x6e1(%rip),%rdi        # ffffffff80201fe1 <_x86_64_asm_ltr+0x14c>
ffffffff80201900:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80201905:	e8 db ec ff ff       	callq  ffffffff802005e5 <kprintf>
            }
            // If read-write match is found
            if (read_buffer[j] == i) {
ffffffff8020190a:	0f b6 83 00 00 50 00 	movzbl 0x500000(%rbx),%eax
ffffffff80201911:	44 39 e0             	cmp    %r12d,%eax
ffffffff80201914:	74 d2                	je     ffffffff802018e8 <verify_read_write+0x112>
ffffffff80201916:	eb 31                	jmp    ffffffff80201949 <verify_read_write+0x173>
ffffffff80201918:	0f b6 83 00 00 50 00 	movzbl 0x500000(%rbx),%eax
ffffffff8020191f:	44 39 e0             	cmp    %r12d,%eax
ffffffff80201922:	75 25                	jne    ffffffff80201949 <verify_read_write+0x173>

    kprintf("Reading from disk ...\n");

    for (i = 0; i < NUM_BLOCKS; i++) {
        read(&abar->ports[port], i * 8, 0, 8, read_buffer);
        for (j = 0; j < BLOCK_SIZE; j++) {
ffffffff80201924:	81 fd ff 0f 00 00    	cmp    $0xfff,%ebp
ffffffff8020192a:	76 bc                	jbe    ffffffff802018e8 <verify_read_write+0x112>
        write1(&abar->ports[port], i * 8, 0, 8, write_buffer);
    }

    kprintf("Reading from disk ...\n");

    for (i = 0; i < NUM_BLOCKS; i++) {
ffffffff8020192c:	41 ff c4             	inc    %r12d
ffffffff8020192f:	41 83 fc 64          	cmp    $0x64,%r12d
ffffffff80201933:	75 84                	jne    ffffffff802018b9 <verify_read_write+0xe3>
            break;
        }
    }

    if (flag == 1)
        kprintf("\nRead and write verified successfully at port %d\n \n", port);
ffffffff80201935:	44 89 fe             	mov    %r15d,%esi
ffffffff80201938:	48 8d 3d b9 11 00 00 	lea    0x11b9(%rip),%rdi        # ffffffff80202af8 <_x86_64_asm_ltr+0xc63>
ffffffff8020193f:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80201944:	e8 9c ec ff ff       	callq  ffffffff802005e5 <kprintf>
}
ffffffff80201949:	48 83 c4 08          	add    $0x8,%rsp
ffffffff8020194d:	5b                   	pop    %rbx
ffffffff8020194e:	5d                   	pop    %rbp
ffffffff8020194f:	41 5c                	pop    %r12
ffffffff80201951:	41 5d                	pop    %r13
ffffffff80201953:	41 5e                	pop    %r14
ffffffff80201955:	41 5f                	pop    %r15
ffffffff80201957:	c3                   	retq   

ffffffff80201958 <probe_port>:

// Search disk in ports impelemented
void probe_port() {
ffffffff80201958:	41 55                	push   %r13
ffffffff8020195a:	41 54                	push   %r12
ffffffff8020195c:	55                   	push   %rbp
ffffffff8020195d:	53                   	push   %rbx
ffffffff8020195e:	48 83 ec 08          	sub    $0x8,%rsp
    uint32_t pi = abar->pi, dt, i = 0;
ffffffff80201962:	48 8d 05 f7 49 00 00 	lea    0x49f7(%rip),%rax        # ffffffff80206360 <abar>
ffffffff80201969:	48 8b 00             	mov    (%rax),%rax
ffffffff8020196c:	8b 68 0c             	mov    0xc(%rax),%ebp
    uint8_t disk_read_write = 0;
ffffffff8020196f:	41 bd 00 00 00 00    	mov    $0x0,%r13d
        kprintf("\nRead and write verified successfully at port %d\n \n", port);
}

// Search disk in ports impelemented
void probe_port() {
    uint32_t pi = abar->pi, dt, i = 0;
ffffffff80201975:	bb 00 00 00 00       	mov    $0x0,%ebx
            } else if (dt == AHCI_DEV_SEMB) {
                kprintf("SEMB drive found at port %d\n", i);
            } else if (dt == AHCI_DEV_PM) {
                kprintf("PM drive found at port %d\n", i);
            } else {
                kprintf("No drive found at port %d\n", i);
ffffffff8020197a:	4c 8d 25 b9 06 00 00 	lea    0x6b9(%rip),%r12        # ffffffff8020203a <_x86_64_asm_ltr+0x1a5>
void probe_port() {
    uint32_t pi = abar->pi, dt, i = 0;
    uint8_t disk_read_write = 0;

    while (i < 32) {
        if (pi & 1) {
ffffffff80201981:	40 f6 c5 01          	test   $0x1,%bpl
ffffffff80201985:	0f 84 ca 00 00 00    	je     ffffffff80201a55 <probe_port+0xfd>
            dt = check_type(&abar->ports[i]);
ffffffff8020198b:	89 df                	mov    %ebx,%edi
ffffffff8020198d:	48 83 c7 02          	add    $0x2,%rdi
ffffffff80201991:	48 c1 e7 07          	shl    $0x7,%rdi
ffffffff80201995:	48 8d 05 c4 49 00 00 	lea    0x49c4(%rip),%rax        # ffffffff80206360 <abar>
ffffffff8020199c:	48 03 38             	add    (%rax),%rdi
ffffffff8020199f:	e8 fa fd ff ff       	callq  ffffffff8020179e <check_type>
            if (dt == AHCI_DEV_SATA) {
ffffffff802019a4:	3d 01 01 00 00       	cmp    $0x101,%eax
ffffffff802019a9:	75 47                	jne    ffffffff802019f2 <probe_port+0x9a>
                kprintf("SATA drive found at port %d\n", i);
ffffffff802019ab:	89 de                	mov    %ebx,%esi
ffffffff802019ad:	48 8d 3d 31 06 00 00 	lea    0x631(%rip),%rdi        # ffffffff80201fe5 <_x86_64_asm_ltr+0x150>
ffffffff802019b4:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff802019b9:	e8 27 ec ff ff       	callq  ffffffff802005e5 <kprintf>
                if (disk_read_write == 0) {
ffffffff802019be:	45 84 ed             	test   %r13b,%r13b
ffffffff802019c1:	0f 85 8e 00 00 00    	jne    ffffffff80201a55 <probe_port+0xfd>
                    port_rebase(&abar->ports[i], i);
ffffffff802019c7:	89 df                	mov    %ebx,%edi
ffffffff802019c9:	48 83 c7 02          	add    $0x2,%rdi
ffffffff802019cd:	48 c1 e7 07          	shl    $0x7,%rdi
ffffffff802019d1:	48 8d 05 88 49 00 00 	lea    0x4988(%rip),%rax        # ffffffff80206360 <abar>
ffffffff802019d8:	48 03 38             	add    (%rax),%rdi
ffffffff802019db:	89 de                	mov    %ebx,%esi
ffffffff802019dd:	e8 06 fd ff ff       	callq  ffffffff802016e8 <port_rebase>
                    verify_read_write(i);
ffffffff802019e2:	0f b6 fb             	movzbl %bl,%edi
ffffffff802019e5:	e8 ec fd ff ff       	callq  ffffffff802017d6 <verify_read_write>
                    disk_read_write = 1;
ffffffff802019ea:	41 bd 01 00 00 00    	mov    $0x1,%r13d
ffffffff802019f0:	eb 63                	jmp    ffffffff80201a55 <probe_port+0xfd>
                }
            } else if (dt == AHCI_DEV_SATAPI) {
ffffffff802019f2:	3d 01 01 14 eb       	cmp    $0xeb140101,%eax
ffffffff802019f7:	75 15                	jne    ffffffff80201a0e <probe_port+0xb6>
                kprintf("SATAPI drive found at port %d\n", i);
ffffffff802019f9:	89 de                	mov    %ebx,%esi
ffffffff802019fb:	48 8d 3d 2e 11 00 00 	lea    0x112e(%rip),%rdi        # ffffffff80202b30 <_x86_64_asm_ltr+0xc9b>
ffffffff80201a02:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80201a07:	e8 d9 eb ff ff       	callq  ffffffff802005e5 <kprintf>
ffffffff80201a0c:	eb 47                	jmp    ffffffff80201a55 <probe_port+0xfd>
            } else if (dt == AHCI_DEV_SEMB) {
ffffffff80201a0e:	3d 01 01 3c c3       	cmp    $0xc33c0101,%eax
ffffffff80201a13:	75 15                	jne    ffffffff80201a2a <probe_port+0xd2>
                kprintf("SEMB drive found at port %d\n", i);
ffffffff80201a15:	89 de                	mov    %ebx,%esi
ffffffff80201a17:	48 8d 3d e4 05 00 00 	lea    0x5e4(%rip),%rdi        # ffffffff80202002 <_x86_64_asm_ltr+0x16d>
ffffffff80201a1e:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80201a23:	e8 bd eb ff ff       	callq  ffffffff802005e5 <kprintf>
ffffffff80201a28:	eb 2b                	jmp    ffffffff80201a55 <probe_port+0xfd>
            } else if (dt == AHCI_DEV_PM) {
ffffffff80201a2a:	3d 01 01 69 96       	cmp    $0x96690101,%eax
ffffffff80201a2f:	75 15                	jne    ffffffff80201a46 <probe_port+0xee>
                kprintf("PM drive found at port %d\n", i);
ffffffff80201a31:	89 de                	mov    %ebx,%esi
ffffffff80201a33:	48 8d 3d e5 05 00 00 	lea    0x5e5(%rip),%rdi        # ffffffff8020201f <_x86_64_asm_ltr+0x18a>
ffffffff80201a3a:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80201a3f:	e8 a1 eb ff ff       	callq  ffffffff802005e5 <kprintf>
ffffffff80201a44:	eb 0f                	jmp    ffffffff80201a55 <probe_port+0xfd>
            } else {
                kprintf("No drive found at port %d\n", i);
ffffffff80201a46:	89 de                	mov    %ebx,%esi
ffffffff80201a48:	4c 89 e7             	mov    %r12,%rdi
ffffffff80201a4b:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80201a50:	e8 90 eb ff ff       	callq  ffffffff802005e5 <kprintf>
            }
        }
        pi >>= 1;
ffffffff80201a55:	d1 ed                	shr    %ebp
        i++;
ffffffff80201a57:	ff c3                	inc    %ebx
// Search disk in ports impelemented
void probe_port() {
    uint32_t pi = abar->pi, dt, i = 0;
    uint8_t disk_read_write = 0;

    while (i < 32) {
ffffffff80201a59:	83 fb 20             	cmp    $0x20,%ebx
ffffffff80201a5c:	0f 85 1f ff ff ff    	jne    ffffffff80201981 <probe_port+0x29>
            }
        }
        pi >>= 1;
        i++;
    }
}
ffffffff80201a62:	48 83 c4 08          	add    $0x8,%rsp
ffffffff80201a66:	5b                   	pop    %rbx
ffffffff80201a67:	5d                   	pop    %rbp
ffffffff80201a68:	41 5c                	pop    %r12
ffffffff80201a6a:	41 5d                	pop    %r13
ffffffff80201a6c:	c3                   	retq   

ffffffff80201a6d <init_ahci>:

void init_ahci(uint32_t bar5) {
ffffffff80201a6d:	48 83 ec 08          	sub    $0x8,%rsp
    // Convert Physical address to virtual address
    abar = (hba_mem_t *)((uint64_t)bar5);
ffffffff80201a71:	89 ff                	mov    %edi,%edi
ffffffff80201a73:	48 8d 05 e6 48 00 00 	lea    0x48e6(%rip),%rax        # ffffffff80206360 <abar>
ffffffff80201a7a:	48 89 38             	mov    %rdi,(%rax)

    // Set bit31 to enable AHCI
    abar->ghc |= 0x80000000;
ffffffff80201a7d:	8b 47 04             	mov    0x4(%rdi),%eax
ffffffff80201a80:	0d 00 00 00 80       	or     $0x80000000,%eax
ffffffff80201a85:	89 47 04             	mov    %eax,0x4(%rdi)

    probe_port();
ffffffff80201a88:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80201a8d:	e8 c6 fe ff ff       	callq  ffffffff80201958 <probe_port>
}
ffffffff80201a92:	48 83 c4 08          	add    $0x8,%rsp
ffffffff80201a96:	c3                   	retq   

ffffffff80201a97 <pci_read_word>:


uint16_t pci_read_word(uint8_t bus, uint8_t slot, uint8_t func, uint8_t offset) {
ffffffff80201a97:	53                   	push   %rbx
ffffffff80201a98:	89 cb                	mov    %ecx,%ebx
        offset & 0xfc: Two lowest bits are always 0 to make sure reads and writes are 32 bits aligned
    */
    address = (uint32_t)(((uint32_t)0x80000000) | (lbus << 16) | (lslot << 11) | (lfunc << 8) | (offset & 0xfc));

    /* write out the address to CONFIG_ADDRESS I/O location (0xCF8) */
    outl(0xCF8, address);
ffffffff80201a9a:	89 c8                	mov    %ecx,%eax
ffffffff80201a9c:	25 fc 00 00 00       	and    $0xfc,%eax
ffffffff80201aa1:	0d 00 00 00 80       	or     $0x80000000,%eax
ffffffff80201aa6:	0f b6 d2             	movzbl %dl,%edx
ffffffff80201aa9:	c1 e2 08             	shl    $0x8,%edx
ffffffff80201aac:	09 c2                	or     %eax,%edx
ffffffff80201aae:	40 0f b6 f6          	movzbl %sil,%esi
ffffffff80201ab2:	c1 e6 0b             	shl    $0xb,%esi
ffffffff80201ab5:	09 d6                	or     %edx,%esi
ffffffff80201ab7:	40 0f b6 ff          	movzbl %dil,%edi
ffffffff80201abb:	c1 e7 10             	shl    $0x10,%edi
ffffffff80201abe:	09 fe                	or     %edi,%esi
ffffffff80201ac0:	bf f8 0c 00 00       	mov    $0xcf8,%edi
ffffffff80201ac5:	e8 fb ed ff ff       	callq  ffffffff802008c5 <outl>

    /* read in the data from CONFIG_DATA I/O location (0xCFC) */
    /* (offset & 2) * 8) = 0 will choose the first word of the 32 bits register */
    return (uint16_t)((inl(0xCFC) >> ((offset & 2) * 8)) & 0xFFFF);
ffffffff80201aca:	bf fc 0c 00 00       	mov    $0xcfc,%edi
ffffffff80201acf:	e8 ed ed ff ff       	callq  ffffffff802008c1 <inl>
ffffffff80201ad4:	83 e3 02             	and    $0x2,%ebx
ffffffff80201ad7:	0f b6 cb             	movzbl %bl,%ecx
ffffffff80201ada:	c1 e1 03             	shl    $0x3,%ecx
ffffffff80201add:	d3 e8                	shr    %cl,%eax
}
ffffffff80201adf:	5b                   	pop    %rbx
ffffffff80201ae0:	c3                   	retq   

ffffffff80201ae1 <pci_remap_bar>:

uint64_t pci_remap_bar(uint8_t bus, uint8_t slot, uint8_t func, uint8_t offset, uint32_t remap_address) {
ffffffff80201ae1:	53                   	push   %rbx
ffffffff80201ae2:	44 89 c3             	mov    %r8d,%ebx
    uint32_t lbus  = (uint32_t)bus;
    uint32_t lslot = (uint32_t)slot;
    uint32_t lfunc = (uint32_t)func;

    address = (uint32_t)((lbus << 16) | (lslot << 11) | (lfunc << 8) | (offset & 0xfc) | ((uint32_t)0x80000000));
    outl(0xCF8, address);
ffffffff80201ae5:	81 e1 fc 00 00 00    	and    $0xfc,%ecx
ffffffff80201aeb:	81 c9 00 00 00 80    	or     $0x80000000,%ecx
ffffffff80201af1:	0f b6 d2             	movzbl %dl,%edx
ffffffff80201af4:	c1 e2 08             	shl    $0x8,%edx
ffffffff80201af7:	09 ca                	or     %ecx,%edx
ffffffff80201af9:	40 0f b6 f6          	movzbl %sil,%esi
ffffffff80201afd:	c1 e6 0b             	shl    $0xb,%esi
ffffffff80201b00:	09 d6                	or     %edx,%esi
ffffffff80201b02:	40 0f b6 ff          	movzbl %dil,%edi
ffffffff80201b06:	c1 e7 10             	shl    $0x10,%edi
ffffffff80201b09:	09 fe                	or     %edi,%esi
ffffffff80201b0b:	bf f8 0c 00 00       	mov    $0xcf8,%edi
ffffffff80201b10:	e8 b0 ed ff ff       	callq  ffffffff802008c5 <outl>
    outl(0xCFC, remap_address);
ffffffff80201b15:	89 de                	mov    %ebx,%esi
ffffffff80201b17:	bf fc 0c 00 00       	mov    $0xcfc,%edi
ffffffff80201b1c:	e8 a4 ed ff ff       	callq  ffffffff802008c5 <outl>

    return (uint32_t)(inl(0xCFC));
ffffffff80201b21:	bf fc 0c 00 00       	mov    $0xcfc,%edi
ffffffff80201b26:	e8 96 ed ff ff       	callq  ffffffff802008c1 <inl>
ffffffff80201b2b:	89 c0                	mov    %eax,%eax
}
ffffffff80201b2d:	5b                   	pop    %rbx
ffffffff80201b2e:	c3                   	retq   

ffffffff80201b2f <device_info>:

void device_info(uint8_t bus, uint8_t device) {
ffffffff80201b2f:	41 57                	push   %r15
ffffffff80201b31:	41 56                	push   %r14
ffffffff80201b33:	41 55                	push   %r13
ffffffff80201b35:	41 54                	push   %r12
ffffffff80201b37:	55                   	push   %rbp
ffffffff80201b38:	53                   	push   %rbx
ffffffff80201b39:	48 83 ec 08          	sub    $0x8,%rsp
    uint16_t vendor_id, device_id, class_subclass;
    uint32_t bar5;
    int func = 0;

    for (func = 0; func < 8; func++) {
ffffffff80201b3d:	bb 00 00 00 00       	mov    $0x0,%ebx
        if ((vendor_id = pci_read_word(bus, device, func ,0)) != 0xFFFF) {
ffffffff80201b42:	44 0f b6 ee          	movzbl %sil,%r13d
ffffffff80201b46:	44 0f b6 e7          	movzbl %dil,%r12d
ffffffff80201b4a:	0f b6 eb             	movzbl %bl,%ebp
ffffffff80201b4d:	b9 00 00 00 00       	mov    $0x0,%ecx
ffffffff80201b52:	89 ea                	mov    %ebp,%edx
ffffffff80201b54:	44 89 ee             	mov    %r13d,%esi
ffffffff80201b57:	44 89 e7             	mov    %r12d,%edi
ffffffff80201b5a:	e8 38 ff ff ff       	callq  ffffffff80201a97 <pci_read_word>
ffffffff80201b5f:	41 89 c6             	mov    %eax,%r14d
ffffffff80201b62:	66 83 f8 ff          	cmp    $0xffff,%ax
ffffffff80201b66:	0f 84 8b 00 00 00    	je     ffffffff80201bf7 <device_info+0xc8>
            device_id = pci_read_word(bus, device, func , 2);
ffffffff80201b6c:	b9 02 00 00 00       	mov    $0x2,%ecx
ffffffff80201b71:	89 ea                	mov    %ebp,%edx
ffffffff80201b73:	44 89 ee             	mov    %r13d,%esi
ffffffff80201b76:	44 89 e7             	mov    %r12d,%edi
ffffffff80201b79:	e8 19 ff ff ff       	callq  ffffffff80201a97 <pci_read_word>
ffffffff80201b7e:	41 89 c7             	mov    %eax,%r15d
            class_subclass = pci_read_word(bus, device, func , 10);
ffffffff80201b81:	b9 0a 00 00 00       	mov    $0xa,%ecx
ffffffff80201b86:	89 ea                	mov    %ebp,%edx
ffffffff80201b88:	44 89 ee             	mov    %r13d,%esi
ffffffff80201b8b:	44 89 e7             	mov    %r12d,%edi
ffffffff80201b8e:	e8 04 ff ff ff       	callq  ffffffff80201a97 <pci_read_word>

            if (((class_subclass & 0xFF00) >> 8) == AHCI_CLASS && (class_subclass & 0x00FF) == AHCI_SUBCLASS) {
ffffffff80201b93:	89 c2                	mov    %eax,%edx
ffffffff80201b95:	66 c1 ea 08          	shr    $0x8,%dx
ffffffff80201b99:	66 83 fa 01          	cmp    $0x1,%dx
ffffffff80201b9d:	75 58                	jne    ffffffff80201bf7 <device_info+0xc8>
ffffffff80201b9f:	3c 06                	cmp    $0x6,%al
ffffffff80201ba1:	75 54                	jne    ffffffff80201bf7 <device_info+0xc8>
                kprintf("*** AHCI controller found ***\n");
ffffffff80201ba3:	48 8d 3d a6 0f 00 00 	lea    0xfa6(%rip),%rdi        # ffffffff80202b50 <_x86_64_asm_ltr+0xcbb>
ffffffff80201baa:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80201baf:	e8 31 ea ff ff       	callq  ffffffff802005e5 <kprintf>
                kprintf("Vendor ID: %x, Device ID: %x, Class code: %x, Subclass: %x\n \n", vendor_id, device_id, AHCI_CLASS, AHCI_SUBCLASS);
ffffffff80201bb4:	41 0f b7 d7          	movzwl %r15w,%edx
ffffffff80201bb8:	41 0f b7 f6          	movzwl %r14w,%esi
ffffffff80201bbc:	41 b8 06 00 00 00    	mov    $0x6,%r8d
ffffffff80201bc2:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff80201bc7:	48 8d 3d a2 0f 00 00 	lea    0xfa2(%rip),%rdi        # ffffffff80202b70 <_x86_64_asm_ltr+0xcdb>
ffffffff80201bce:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80201bd3:	e8 0d ea ff ff       	callq  ffffffff802005e5 <kprintf>

                // Move the bar5 (beyond physical memory space) to a place you can read (within physical memory space)
                bar5 = pci_remap_bar(bus, device, func , 0x24, BAR_MEM);
ffffffff80201bd8:	41 b8 00 60 0a 00    	mov    $0xa6000,%r8d
ffffffff80201bde:	b9 24 00 00 00       	mov    $0x24,%ecx
ffffffff80201be3:	89 ea                	mov    %ebp,%edx
ffffffff80201be5:	44 89 ee             	mov    %r13d,%esi
ffffffff80201be8:	44 89 e7             	mov    %r12d,%edi
ffffffff80201beb:	e8 f1 fe ff ff       	callq  ffffffff80201ae1 <pci_remap_bar>
                init_ahci(bar5);
ffffffff80201bf0:	89 c7                	mov    %eax,%edi
ffffffff80201bf2:	e8 76 fe ff ff       	callq  ffffffff80201a6d <init_ahci>
void device_info(uint8_t bus, uint8_t device) {
    uint16_t vendor_id, device_id, class_subclass;
    uint32_t bar5;
    int func = 0;

    for (func = 0; func < 8; func++) {
ffffffff80201bf7:	ff c3                	inc    %ebx
ffffffff80201bf9:	83 fb 08             	cmp    $0x8,%ebx
ffffffff80201bfc:	0f 85 48 ff ff ff    	jne    ffffffff80201b4a <device_info+0x1b>
                bar5 = pci_remap_bar(bus, device, func , 0x24, BAR_MEM);
                init_ahci(bar5);
            }
        }
    }
}
ffffffff80201c02:	48 83 c4 08          	add    $0x8,%rsp
ffffffff80201c06:	5b                   	pop    %rbx
ffffffff80201c07:	5d                   	pop    %rbp
ffffffff80201c08:	41 5c                	pop    %r12
ffffffff80201c0a:	41 5d                	pop    %r13
ffffffff80201c0c:	41 5e                	pop    %r14
ffffffff80201c0e:	41 5f                	pop    %r15
ffffffff80201c10:	c3                   	retq   

ffffffff80201c11 <init_pci>:

void init_pci() {
ffffffff80201c11:	41 54                	push   %r12
ffffffff80201c13:	55                   	push   %rbp
ffffffff80201c14:	53                   	push   %rbx
    uint8_t bus = 0, slot;

    kprintf("Walking PCI configuration space ...\n");
ffffffff80201c15:	48 8d 3d 94 0f 00 00 	lea    0xf94(%rip),%rdi        # ffffffff80202bb0 <_x86_64_asm_ltr+0xd1b>
ffffffff80201c1c:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80201c21:	e8 bf e9 ff ff       	callq  ffffffff802005e5 <kprintf>
ffffffff80201c26:	41 bc 00 00 00 00    	mov    $0x0,%r12d
ffffffff80201c2c:	bb 00 00 00 00       	mov    $0x0,%ebx
    // 256 buses, each with up to 32 devices
    do {
        for (slot = 0; slot < 32; slot++)
            device_info(bus, slot);
ffffffff80201c31:	41 0f b6 ec          	movzbl %r12b,%ebp
ffffffff80201c35:	89 de                	mov    %ebx,%esi
ffffffff80201c37:	89 ef                	mov    %ebp,%edi
ffffffff80201c39:	e8 f1 fe ff ff       	callq  ffffffff80201b2f <device_info>
ffffffff80201c3e:	ff c3                	inc    %ebx
    uint8_t bus = 0, slot;

    kprintf("Walking PCI configuration space ...\n");
    // 256 buses, each with up to 32 devices
    do {
        for (slot = 0; slot < 32; slot++)
ffffffff80201c40:	83 fb 20             	cmp    $0x20,%ebx
ffffffff80201c43:	75 f0                	jne    ffffffff80201c35 <init_pci+0x24>
ffffffff80201c45:	41 ff c4             	inc    %r12d
            device_info(bus, slot);
        bus++;
    } while (bus != 0);
ffffffff80201c48:	41 81 fc 00 01 00 00 	cmp    $0x100,%r12d
ffffffff80201c4f:	75 db                	jne    ffffffff80201c2c <init_pci+0x1b>
 }
ffffffff80201c51:	5b                   	pop    %rbx
ffffffff80201c52:	5d                   	pop    %rbp
ffffffff80201c53:	41 5c                	pop    %r12
ffffffff80201c55:	c3                   	retq   

ffffffff80201c56 <memset>:
#include <sys/defs.h>

void *memset(void *str, int c, size_t n) {
ffffffff80201c56:	48 89 f8             	mov    %rdi,%rax
    int i;
    char *s = (char *)str;

    for (i = 0; i < n; i++)
ffffffff80201c59:	48 85 d2             	test   %rdx,%rdx
ffffffff80201c5c:	74 19                	je     ffffffff80201c77 <memset+0x21>
ffffffff80201c5e:	41 b8 00 00 00 00    	mov    $0x0,%r8d
ffffffff80201c64:	b9 00 00 00 00       	mov    $0x0,%ecx
        s[i] = c;
ffffffff80201c69:	42 88 34 00          	mov    %sil,(%rax,%r8,1)

void *memset(void *str, int c, size_t n) {
    int i;
    char *s = (char *)str;

    for (i = 0; i < n; i++)
ffffffff80201c6d:	ff c1                	inc    %ecx
ffffffff80201c6f:	4c 63 c1             	movslq %ecx,%r8
ffffffff80201c72:	49 39 d0             	cmp    %rdx,%r8
ffffffff80201c75:	72 f2                	jb     ffffffff80201c69 <memset+0x13>
        s[i] = c;

    return s;
}
ffffffff80201c77:	f3 c3                	repz retq 

ffffffff80201c79 <timer_interrupt>:
#define FREQUENCY 18

int i = 0, timer = 0;

void timer_interrupt() {
    timer++;
ffffffff80201c79:	48 8d 05 ac 25 00 00 	lea    0x25ac(%rip),%rax        # ffffffff8020422c <timer>
ffffffff80201c80:	8b 30                	mov    (%rax),%esi
ffffffff80201c82:	8d 4e 01             	lea    0x1(%rsi),%ecx
ffffffff80201c85:	89 08                	mov    %ecx,(%rax)
    if (timer % FREQUENCY == 0) {
ffffffff80201c87:	ba 39 8e e3 38       	mov    $0x38e38e39,%edx
ffffffff80201c8c:	89 c8                	mov    %ecx,%eax
ffffffff80201c8e:	f7 ea                	imul   %edx
ffffffff80201c90:	c1 fa 02             	sar    $0x2,%edx
ffffffff80201c93:	89 c8                	mov    %ecx,%eax
ffffffff80201c95:	c1 f8 1f             	sar    $0x1f,%eax
ffffffff80201c98:	29 c2                	sub    %eax,%edx
ffffffff80201c9a:	89 d0                	mov    %edx,%eax
ffffffff80201c9c:	c1 e0 04             	shl    $0x4,%eax
ffffffff80201c9f:	8d 04 50             	lea    (%rax,%rdx,2),%eax
ffffffff80201ca2:	39 c1                	cmp    %eax,%ecx
ffffffff80201ca4:	75 31                	jne    ffffffff80201cd7 <timer_interrupt+0x5e>
#define COLUMN 30
#define FREQUENCY 18

int i = 0, timer = 0;

void timer_interrupt() {
ffffffff80201ca6:	48 83 ec 08          	sub    $0x8,%rsp
    timer++;
    if (timer % FREQUENCY == 0) {
        kprintf_pos(ROW, COLUMN, "Time since boot: %d s", ++i);
ffffffff80201caa:	48 8d 05 7f 25 00 00 	lea    0x257f(%rip),%rax        # ffffffff80204230 <i>
ffffffff80201cb1:	8b 38                	mov    (%rax),%edi
ffffffff80201cb3:	8d 4f 01             	lea    0x1(%rdi),%ecx
ffffffff80201cb6:	89 08                	mov    %ecx,(%rax)
ffffffff80201cb8:	48 8d 15 96 03 00 00 	lea    0x396(%rip),%rdx        # ffffffff80202055 <_x86_64_asm_ltr+0x1c0>
ffffffff80201cbf:	be 1e 00 00 00       	mov    $0x1e,%esi
ffffffff80201cc4:	bf 18 00 00 00       	mov    $0x18,%edi
ffffffff80201cc9:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff80201cce:	e8 25 eb ff ff       	callq  ffffffff802007f8 <kprintf_pos>
    }
}
ffffffff80201cd3:	48 83 c4 08          	add    $0x8,%rsp
ffffffff80201cd7:	f3 c3                	repz retq 

ffffffff80201cd9 <init_gdt>:
static struct gdtr_t gdtr = { sizeof(gdt), (uint64_t)gdt };
static struct tss_t tss;

void _x86_64_asm_lgdt(struct gdtr_t *gdtr, uint64_t cs_idx, uint64_t ds_idx);
void _x86_64_asm_ltr(uint64_t tss_idx);
void init_gdt() {
ffffffff80201cd9:	48 83 ec 08          	sub    $0x8,%rsp
  struct sys_segment_descriptor *sd = (struct sys_segment_descriptor*)&gdt[5]; // 6th&7th entry in GDT
  sd->sd_lolimit = sizeof(struct tss_t) - 1;
ffffffff80201cdd:	66 c7 05 e2 47 00 00 	movw   $0x67,0x47e2(%rip)        # ffffffff802064c8 <gdt+0x28>
ffffffff80201ce4:	67 00 
  sd->sd_lobase = ((uint64_t)&tss);
ffffffff80201ce6:	48 8d 0d 53 25 00 00 	lea    0x2553(%rip),%rcx        # ffffffff80204240 <tss>
ffffffff80201ced:	48 89 c8             	mov    %rcx,%rax
ffffffff80201cf0:	25 ff ff ff 00       	and    $0xffffff,%eax
ffffffff80201cf5:	48 c1 e0 10          	shl    $0x10,%rax
ffffffff80201cf9:	48 89 c2             	mov    %rax,%rdx
ffffffff80201cfc:	48 b8 ff ff 00 00 00 	movabs $0xffffff000000ffff,%rax
ffffffff80201d03:	ff ff ff 
ffffffff80201d06:	48 23 05 bb 47 00 00 	and    0x47bb(%rip),%rax        # ffffffff802064c8 <gdt+0x28>
ffffffff80201d0d:	48 09 d0             	or     %rdx,%rax
ffffffff80201d10:	48 89 05 b1 47 00 00 	mov    %rax,0x47b1(%rip)        # ffffffff802064c8 <gdt+0x28>
  sd->sd_type = 9; // TSS
  sd->sd_dpl = 0;
  sd->sd_p = 1;
ffffffff80201d17:	c6 05 af 47 00 00 89 	movb   $0x89,0x47af(%rip)        # ffffffff802064cd <gdt+0x2d>
  sd->sd_hilimit = 0;
ffffffff80201d1e:	48 c1 e8 30          	shr    $0x30,%rax
  sd->sd_gran = 0;
ffffffff80201d22:	83 e0 70             	and    $0x70,%eax
ffffffff80201d25:	88 05 a3 47 00 00    	mov    %al,0x47a3(%rip)        # ffffffff802064ce <gdt+0x2e>
  sd->sd_hibase = ((uint64_t)&tss) >> 24;
ffffffff80201d2b:	48 89 c8             	mov    %rcx,%rax
ffffffff80201d2e:	48 c1 e8 18          	shr    $0x18,%rax
ffffffff80201d32:	88 05 97 47 00 00    	mov    %al,0x4797(%rip)        # ffffffff802064cf <gdt+0x2f>
ffffffff80201d38:	48 c1 e9 20          	shr    $0x20,%rcx
ffffffff80201d3c:	89 0d 8e 47 00 00    	mov    %ecx,0x478e(%rip)        # ffffffff802064d0 <gdt+0x30>

  _x86_64_asm_lgdt(&gdtr, 8, 16);
ffffffff80201d42:	ba 10 00 00 00       	mov    $0x10,%edx
ffffffff80201d47:	be 08 00 00 00       	mov    $0x8,%esi
ffffffff80201d4c:	48 8d 3d 5d b8 08 00 	lea    0x8b85d(%rip),%rdi        # ffffffff8028d5b0 <gdtr>
ffffffff80201d53:	e8 1b 01 00 00       	callq  ffffffff80201e73 <_x86_64_asm_lgdt>
  _x86_64_asm_ltr(0x28);
ffffffff80201d58:	bf 28 00 00 00       	mov    $0x28,%edi
ffffffff80201d5d:	e8 33 01 00 00       	callq  ffffffff80201e95 <_x86_64_asm_ltr>
}
ffffffff80201d62:	48 83 c4 08          	add    $0x8,%rsp
ffffffff80201d66:	c3                   	retq   

ffffffff80201d67 <set_tss_rsp>:

void set_tss_rsp(void *rsp) {
  tss.rsp0 = rsp;
ffffffff80201d67:	48 89 3d d6 24 00 00 	mov    %rdi,0x24d6(%rip)        # ffffffff80204244 <tss+0x4>
ffffffff80201d6e:	c3                   	retq   

ffffffff80201d6f <_switch_to_ring_3>:
.text

.global _switch_to_ring_3
_switch_to_ring_3:

        cli
ffffffff80201d6f:	fa                   	cli    
        movq $0x23, %rax
ffffffff80201d70:	48 c7 c0 23 00 00 00 	mov    $0x23,%rax
        movq %rax, %ds
ffffffff80201d77:	48 8e d8             	mov    %rax,%ds
        movq %rax, %es
ffffffff80201d7a:	48 8e c0             	mov    %rax,%es
        movq %rax, %fs
ffffffff80201d7d:	48 8e e0             	mov    %rax,%fs
        movq %rax, %gs
ffffffff80201d80:	48 8e e8             	mov    %rax,%gs

        movq %rsp, %rax
ffffffff80201d83:	48 89 e0             	mov    %rsp,%rax
        pushq $0x23
ffffffff80201d86:	6a 23                	pushq  $0x23
        pushq %rax
ffffffff80201d88:	50                   	push   %rax
        pushfq
ffffffff80201d89:	9c                   	pushfq 
        # popq %rax
        # orq $0x200, %rax
        # pushq %rax
        pushq $0x1b
ffffffff80201d8a:	6a 1b                	pushq  $0x1b
        pushq %rdi
ffffffff80201d8c:	57                   	push   %rdi
        iretq
ffffffff80201d8d:	48 cf                	iretq  

ffffffff80201d8f <_x86_64_asm_pic_remapping>:

.global _x86_64_asm_pic_remapping
_x86_64_asm_pic_remapping:

    # al is used for i/o port access
    movb $0x11, %al
ffffffff80201d8f:	b0 11                	mov    $0x11,%al
    outb %al, $0x20  # Restart PIC1. 0x20 is command port for PIC1
ffffffff80201d91:	e6 20                	out    %al,$0x20
    outb %al, $0xA0  # Restart PIC2. 0xA0 is command port for PIC2
ffffffff80201d93:	e6 a0                	out    %al,$0xa0

    movb $0x20, %al
ffffffff80201d95:	b0 20                	mov    $0x20,%al
    outb %al, $0x21  # Start PIC1 at 32 (0x20)
ffffffff80201d97:	e6 21                	out    %al,$0x21
    movb $0x28, %al
ffffffff80201d99:	b0 28                	mov    $0x28,%al
    outb %al, $0xA1  # Start PIC2 at 40 (0x28)
ffffffff80201d9b:	e6 a1                	out    %al,$0xa1

    movb $0x04, %al
ffffffff80201d9d:	b0 04                	mov    $0x4,%al
    outb %al, $0x21  # Cascade PIC2 to PIC1
ffffffff80201d9f:	e6 21                	out    %al,$0x21
    movb $0x02, %al
ffffffff80201da1:	b0 02                	mov    $0x2,%al
    outb  %al, $0xA1
ffffffff80201da3:	e6 a1                	out    %al,$0xa1

    movb $0x01, %al
ffffffff80201da5:	b0 01                	mov    $0x1,%al
    outb %al, $0x21
ffffffff80201da7:	e6 21                	out    %al,$0x21
    outb %al, $0xA1
ffffffff80201da9:	e6 a1                	out    %al,$0xa1

    sti
ffffffff80201dab:	fb                   	sti    
    retq
ffffffff80201dac:	c3                   	retq   

ffffffff80201dad <isr0>:
        # Set interrupt
        # sti
        iretq
.endm

INTERRUPT_HANDLER 0
ffffffff80201dad:	fa                   	cli    
ffffffff80201dae:	50                   	push   %rax
ffffffff80201daf:	53                   	push   %rbx
ffffffff80201db0:	51                   	push   %rcx
ffffffff80201db1:	52                   	push   %rdx
ffffffff80201db2:	55                   	push   %rbp
ffffffff80201db3:	56                   	push   %rsi
ffffffff80201db4:	57                   	push   %rdi
ffffffff80201db5:	41 50                	push   %r8
ffffffff80201db7:	41 51                	push   %r9
ffffffff80201db9:	e8 5e e6 ff ff       	callq  ffffffff8020041c <interrupt_handler0>
ffffffff80201dbe:	41 59                	pop    %r9
ffffffff80201dc0:	41 58                	pop    %r8
ffffffff80201dc2:	5f                   	pop    %rdi
ffffffff80201dc3:	5e                   	pop    %rsi
ffffffff80201dc4:	5d                   	pop    %rbp
ffffffff80201dc5:	5a                   	pop    %rdx
ffffffff80201dc6:	59                   	pop    %rcx
ffffffff80201dc7:	5b                   	pop    %rbx
ffffffff80201dc8:	58                   	pop    %rax
ffffffff80201dc9:	b0 20                	mov    $0x20,%al
ffffffff80201dcb:	e6 20                	out    %al,$0x20
ffffffff80201dcd:	48 cf                	iretq  

ffffffff80201dcf <isr32>:
INTERRUPT_HANDLER 32
ffffffff80201dcf:	fa                   	cli    
ffffffff80201dd0:	50                   	push   %rax
ffffffff80201dd1:	53                   	push   %rbx
ffffffff80201dd2:	51                   	push   %rcx
ffffffff80201dd3:	52                   	push   %rdx
ffffffff80201dd4:	55                   	push   %rbp
ffffffff80201dd5:	56                   	push   %rsi
ffffffff80201dd6:	57                   	push   %rdi
ffffffff80201dd7:	41 50                	push   %r8
ffffffff80201dd9:	41 51                	push   %r9
ffffffff80201ddb:	e8 3e e6 ff ff       	callq  ffffffff8020041e <interrupt_handler32>
ffffffff80201de0:	41 59                	pop    %r9
ffffffff80201de2:	41 58                	pop    %r8
ffffffff80201de4:	5f                   	pop    %rdi
ffffffff80201de5:	5e                   	pop    %rsi
ffffffff80201de6:	5d                   	pop    %rbp
ffffffff80201de7:	5a                   	pop    %rdx
ffffffff80201de8:	59                   	pop    %rcx
ffffffff80201de9:	5b                   	pop    %rbx
ffffffff80201dea:	58                   	pop    %rax
ffffffff80201deb:	b0 20                	mov    $0x20,%al
ffffffff80201ded:	e6 20                	out    %al,$0x20
ffffffff80201def:	48 cf                	iretq  

ffffffff80201df1 <isr33>:
INTERRUPT_HANDLER 33
ffffffff80201df1:	fa                   	cli    
ffffffff80201df2:	50                   	push   %rax
ffffffff80201df3:	53                   	push   %rbx
ffffffff80201df4:	51                   	push   %rcx
ffffffff80201df5:	52                   	push   %rdx
ffffffff80201df6:	55                   	push   %rbp
ffffffff80201df7:	56                   	push   %rsi
ffffffff80201df8:	57                   	push   %rdi
ffffffff80201df9:	41 50                	push   %r8
ffffffff80201dfb:	41 51                	push   %r9
ffffffff80201dfd:	e8 1e e6 ff ff       	callq  ffffffff80200420 <interrupt_handler33>
ffffffff80201e02:	41 59                	pop    %r9
ffffffff80201e04:	41 58                	pop    %r8
ffffffff80201e06:	5f                   	pop    %rdi
ffffffff80201e07:	5e                   	pop    %rsi
ffffffff80201e08:	5d                   	pop    %rbp
ffffffff80201e09:	5a                   	pop    %rdx
ffffffff80201e0a:	59                   	pop    %rcx
ffffffff80201e0b:	5b                   	pop    %rbx
ffffffff80201e0c:	58                   	pop    %rax
ffffffff80201e0d:	b0 20                	mov    $0x20,%al
ffffffff80201e0f:	e6 20                	out    %al,$0x20
ffffffff80201e11:	48 cf                	iretq  

ffffffff80201e13 <isr128>:
INTERRUPT_HANDLER 128
ffffffff80201e13:	fa                   	cli    
ffffffff80201e14:	50                   	push   %rax
ffffffff80201e15:	53                   	push   %rbx
ffffffff80201e16:	51                   	push   %rcx
ffffffff80201e17:	52                   	push   %rdx
ffffffff80201e18:	55                   	push   %rbp
ffffffff80201e19:	56                   	push   %rsi
ffffffff80201e1a:	57                   	push   %rdi
ffffffff80201e1b:	41 50                	push   %r8
ffffffff80201e1d:	41 51                	push   %r9
ffffffff80201e1f:	e8 fe e5 ff ff       	callq  ffffffff80200422 <interrupt_handler128>
ffffffff80201e24:	41 59                	pop    %r9
ffffffff80201e26:	41 58                	pop    %r8
ffffffff80201e28:	5f                   	pop    %rdi
ffffffff80201e29:	5e                   	pop    %rsi
ffffffff80201e2a:	5d                   	pop    %rbp
ffffffff80201e2b:	5a                   	pop    %rdx
ffffffff80201e2c:	59                   	pop    %rcx
ffffffff80201e2d:	5b                   	pop    %rbx
ffffffff80201e2e:	58                   	pop    %rax
ffffffff80201e2f:	b0 20                	mov    $0x20,%al
ffffffff80201e31:	e6 20                	out    %al,$0x20
ffffffff80201e33:	48 cf                	iretq  

ffffffff80201e35 <_context_switch>:
.text

.global _context_switch
_context_switch:

    cli
ffffffff80201e35:	fa                   	cli    
    pushq %rax
ffffffff80201e36:	50                   	push   %rax
    pushq %rbx
ffffffff80201e37:	53                   	push   %rbx
    pushq %rcx
ffffffff80201e38:	51                   	push   %rcx
    pushq %rdx
ffffffff80201e39:	52                   	push   %rdx
    pushq %rbp
ffffffff80201e3a:	55                   	push   %rbp
    pushq %r8
ffffffff80201e3b:	41 50                	push   %r8
    pushq %r9
ffffffff80201e3d:	41 51                	push   %r9
    pushq %r10
ffffffff80201e3f:	41 52                	push   %r10
    pushq %r11
ffffffff80201e41:	41 53                	push   %r11
    pushq %r12
ffffffff80201e43:	41 54                	push   %r12
    pushq %r13
ffffffff80201e45:	41 55                	push   %r13
    pushq %r14
ffffffff80201e47:	41 56                	push   %r14
    pushq %r15
ffffffff80201e49:	41 57                	push   %r15

    pushq %rdi
ffffffff80201e4b:	57                   	push   %rdi

    movq %rsp, 0(%rdi)
ffffffff80201e4c:	48 89 27             	mov    %rsp,(%rdi)
    movq 0(%rsi), %rsp
ffffffff80201e4f:	48 8b 26             	mov    (%rsi),%rsp

    popq %rdi
ffffffff80201e52:	5f                   	pop    %rdi

    popq %r15
ffffffff80201e53:	41 5f                	pop    %r15
    popq %r14
ffffffff80201e55:	41 5e                	pop    %r14
    popq %r13
ffffffff80201e57:	41 5d                	pop    %r13
    popq %r12
ffffffff80201e59:	41 5c                	pop    %r12
    popq %r11
ffffffff80201e5b:	41 5b                	pop    %r11
    popq %r10
ffffffff80201e5d:	41 5a                	pop    %r10
    popq %r9
ffffffff80201e5f:	41 59                	pop    %r9
    popq %r8
ffffffff80201e61:	41 58                	pop    %r8
    popq %rbp
ffffffff80201e63:	5d                   	pop    %rbp
    popq %rdx
ffffffff80201e64:	5a                   	pop    %rdx
    popq %rcx
ffffffff80201e65:	59                   	pop    %rcx
    popq %rbx
ffffffff80201e66:	5b                   	pop    %rbx
    popq %rax
ffffffff80201e67:	58                   	pop    %rax

    sti
ffffffff80201e68:	fb                   	sti    
    retq
ffffffff80201e69:	c3                   	retq   

ffffffff80201e6a <_x86_64_inb>:
.text

.global _x86_64_inb
_x86_64_inb:
	movq %rdi, %rdx
ffffffff80201e6a:	48 89 fa             	mov    %rdi,%rdx
	inb %dx, %al
ffffffff80201e6d:	ec                   	in     (%dx),%al
	retq
ffffffff80201e6e:	c3                   	retq   

ffffffff80201e6f <_x86_64_asm_lidt>:

# Load a new IDT
.global _x86_64_asm_lidt
_x86_64_asm_lidt:

    lidt (%rdi)
ffffffff80201e6f:	0f 01 1f             	lidt   (%rdi)
    retq
ffffffff80201e72:	c3                   	retq   

ffffffff80201e73 <_x86_64_asm_lgdt>:
#  parameter 2: new code descriptor offset
#  parameter 3: new data descriptor offset
.global _x86_64_asm_lgdt
_x86_64_asm_lgdt:

  lgdt (%rdi)
ffffffff80201e73:	0f 01 17             	lgdt   (%rdi)

  pushq %rsi                  # push code selector
ffffffff80201e76:	56                   	push   %rsi
  movabsq $.done, %r10
ffffffff80201e77:	49 ba 85 1e 20 80 ff 	movabs $0xffffffff80201e85,%r10
ffffffff80201e7e:	ff ff ff 
  pushq %r10                  # push return address
ffffffff80201e81:	41 52                	push   %r10
  lretq                       # far-return to new cs descriptor ( the retq below )
ffffffff80201e83:	48 cb                	lretq  

ffffffff80201e85 <.done>:
.done:
  movq %rdx, %es
ffffffff80201e85:	48 8e c2             	mov    %rdx,%es
  movq %rdx, %fs
ffffffff80201e88:	48 8e e2             	mov    %rdx,%fs
  movq %rdx, %gs
ffffffff80201e8b:	48 8e ea             	mov    %rdx,%gs
  movq %rdx, %ds
ffffffff80201e8e:	48 8e da             	mov    %rdx,%ds
  movq %rdx, %ss
ffffffff80201e91:	48 8e d2             	mov    %rdx,%ss
  retq
ffffffff80201e94:	c3                   	retq   

ffffffff80201e95 <_x86_64_asm_ltr>:
######
# load a new TSS
#  parameter 1: index of TSS in GDT
.global _x86_64_asm_ltr
_x86_64_asm_ltr:
  ltr %di
ffffffff80201e95:	0f 00 df             	ltr    %di
  retq
ffffffff80201e98:	c3                   	retq   
